<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Touchy Effects</title>
  <style>
    html, body {
      margin: 0; height: 100%;
      background: #050510;
      overflow: hidden;
      touch-action: none; /* critical for iPad */
    }
    canvas { display:block; width:100vw; height:100vh; }

    .panel {
      position: fixed;
      left: 12px; top: 12px;
      width: min(420px, calc(100vw - 24px));
      z-index: 10;

      color: rgba(255,255,255,0.92);
      font: 600 16px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;

      background: rgba(255,255,255,0.10);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-radius: 18px;
      padding: 12px;
      box-shadow: 0 10px 24px rgba(0,0,0,0.35);
      user-select: none;
      -webkit-user-select: none;
      transition: opacity 220ms ease;
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    button, select {
      font: 700 16px/1.1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      padding: 10px 12px;
      border: 0;
      border-radius: 14px;
      background: rgba(255,255,255,0.14);
      color: rgba(255,255,255,0.95);
      outline: none;
    }
    button:active { transform: scale(0.98); }
    select { flex: 1; min-width: 220px; }

    .sliders {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .slider {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      background: rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 10px 12px;
    }
    .slider label {
      display: block;
      font-weight: 700;
      font-size: 14px;
      color: rgba(255,255,255,0.85);
      margin-bottom: 6px;
    }
    .slider .value {
      font-size: 13px;
      font-weight: 700;
      color: rgba(255,255,255,0.75);
      min-width: 64px;
      text-align: right;
    }
    input[type="range"] {
      width: 100%;
      accent-color: rgba(255,255,255,0.9);
    }

    .hint {
      position: fixed; right: 12px; top: 12px;
      z-index: 10;
      font: 600 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: rgba(255,255,255,0.70);
      background: rgba(255,255,255,0.08);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 10px 12px;
      border-radius: 14px;
      user-select: none;
      -webkit-user-select: none;
      transition: opacity 220ms ease;
    }

    .hidden { opacity: 0; pointer-events: none; }
  </style>
</head>
<body>
  <div id="panel" class="panel">
    <div class="row">
      <button id="clearBtn">Clear</button>
      <button id="lockBtn" title="Hide UI after a few seconds">Toddler UI: ON</button>
    </div>

    <div class="row">
      <select id="effectSelect"></select>
    </div>

    <div id="sliders" class="sliders"></div>
  </div>

  <div id="hint" class="hint">Touch & drag ‚ú® (multi-touch works)</div>
  <canvas id="c"></canvas>

<script>
(() => {
  // ---------- Canvas setup ----------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: true });

  const gooCanvas = document.createElement("canvas");
  const gtx = gooCanvas.getContext("2d", { alpha: true });

  function resize() {
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";

    gooCanvas.width = canvas.width;
    gooCanvas.height = canvas.height;

    // Use CSS pixel coordinates in drawing
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    gtx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener("resize", resize, { passive: true });
  resize();

  // ---------- UI ----------
  const panel = document.getElementById("panel");
  const hint = document.getElementById("hint");
  const slidersEl = document.getElementById("sliders");
  const effectSelect = document.getElementById("effectSelect");

  let toddlerMode = true; // auto-hide UI
  let lastInteractionAt = performance.now();
  const UI_HIDE_MS = 3500;

  function pokeUI() {
    lastInteractionAt = performance.now();
    if (toddlerMode) {
      panel.classList.remove("hidden");
      hint.classList.remove("hidden");
    }
  }

  document.getElementById("lockBtn").onclick = () => {
    toddlerMode = !toddlerMode;
    document.getElementById("lockBtn").textContent = "Toddler UI: " + (toddlerMode ? "ON" : "OFF");
    if (!toddlerMode) {
      panel.classList.remove("hidden");
      hint.classList.remove("hidden");
    }
    pokeUI();
  };

  document.getElementById("clearBtn").onclick = () => {
    state.particles.length = 0;
    state.blobs.length = 0;
    state.bubbles.length = 0;
    state.ribbons.clear();
    state.trails.clear();
    pokeUI();
  };

  // Prevent UI touches from painting the canvas:
  panel.addEventListener("pointerdown", (e) => { e.stopPropagation(); pokeUI(); }, { passive: true });
  panel.addEventListener("pointermove", (e) => { e.stopPropagation(); pokeUI(); }, { passive: true });

  // ---------- Helpers ----------
  const rand = (a,b)=>a+Math.random()*(b-a);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;

  function fmt(v, step) {
    // show nice values for slider labels
    const s = step || 1;
    const d = (s < 1) ? (String(s).split(".")[1]?.length || 0) : 0;
    return v.toFixed(d);
  }

  // ---------- Effect system ----------
  // Each effect defines sliders with names + ranges, and handlers for pointer events + draw/update.
  // Sliders are stored in effectParams[effectId][key] and changed dynamically.
  const effects = [
    {
      id: "sparklyGoo",
      name: "‚ú® Sparkly Goo",
      sliders: [
        { key: "goo",      label: "Goo Amount",    min: 0, max: 1, step: 0.01, def: 1 },
        { key: "sparkle",  label: "Sparkle Amount",min: 0, max: 1, step: 0.01, def: 1 },
        { key: "size",     label: "Blob Size",     min: 10, max: 42, step: 1, def: 24 },
        { key: "blur",     label: "Goo Blur",      min: 0, max: 24, step: 1, def: 12 },
        { key: "gravity",  label: "Floatiness",    min: -1.2, max: 1.2, step: 0.05, def: -0.35 },
      ],
      onDown(x,y,meta){ burstStars(x,y, 18, 0.8); dropBlob(x,y, meta, 1.3); },
      onMove(x,y,meta){
        const speed = meta.speed;
        const gooAmt = p("goo"), spAmt = p("sparkle");
        if (gooAmt > 0.01) dropBlob(x,y, meta, clamp(speed/14, 0.6, 2.0) * gooAmt);
        if (spAmt > 0.01 && speed > 1.5) burstSparkles(x,y, Math.floor(clamp(speed/2, 2, 14) * spAmt));
      },
      drawBackground(){ drawSoftBackground(); },
      drawOverlay(){ drawTrails(0.16); },
      tick(dt){ /* uses global particle systems */ }
    },

    {
      id: "starBursts",
      name: "‚≠ê Star Bursts",
      sliders: [
        { key: "rate",     label: "Burst Rate",     min: 0.1, max: 2.0, step: 0.05, def: 1.0 },
        { key: "points",   label: "Star Points",    min: 4, max: 10, step: 1, def: 5 },
        { key: "radius",   label: "Star Size",      min: 10, max: 60, step: 1, def: 28 },
        { key: "spark",    label: "Glitter",        min: 0, max: 1, step: 0.01, def: 0.7 },
        { key: "wobble",   label: "Wobble",         min: 0, max: 1, step: 0.01, def: 0.5 },
      ],
      onDown(x,y){ spawnBurstStar(x,y, 1.0); },
      onMove(x,y,meta){
        // Emit based on distance moved
        const rate = p("rate");
        meta.emitAccumulator = (meta.emitAccumulator || 0) + meta.dist * 0.02 * rate;
        while (meta.emitAccumulator > 1) {
          meta.emitAccumulator -= 1;
          spawnBurstStar(x,y, 0.75);
        }
        if (p("spark") > 0.01 && meta.speed > 2) burstSparkles(x,y, Math.floor(clamp(meta.speed, 0, 12) * p("spark")));
      },
      drawBackground(){ drawSoftBackground(); },
      drawOverlay(){ drawTrails(0.10); }
    },

    {
      id: "fireworks",
      name: "üéÜ Fireworks Paint",
      sliders: [
        { key: "pop",      label: "Pop Size",       min: 10, max: 90, step: 1, def: 48 },
        { key: "count",    label: "Particles",      min: 10, max: 80, step: 1, def: 34 },
        { key: "spread",   label: "Spread",         min: 0.3, max: 3.0, step: 0.05, def: 1.2 },
        { key: "drag",     label: "Air Drag",       min: 0.0, max: 0.25, step: 0.01, def: 0.10 },
        { key: "glow",     label: "Glow",           min: 0, max: 1, step: 0.01, def: 0.85 },
      ],
      onDown(x,y){ fireworkPop(x,y, 1.0); },
      onMove(x,y,meta){
        // Pop occasionally, more when moving fast
        meta.popTimer = (meta.popTimer || 0) - meta.dt;
        const interval = lerp(0.22, 0.05, clamp(meta.speed/18, 0, 1));
        if (meta.popTimer <= 0) {
          meta.popTimer = interval;
          fireworkPop(x,y, 0.9);
        }
      },
      drawBackground(){ drawSoftBackground(); },
      drawOverlay(){ drawTrails(0.08); }
    },

    {
      id: "bubbles",
      name: "ü´ß Bubbles & Pops",
      sliders: [
        { key: "bubbleSize", label: "Bubble Size",  min: 10, max: 70, step: 1, def: 34 },
        { key: "rise",       label: "Rise Speed",   min: 0.2, max: 2.2, step: 0.05, def: 1.0 },
        { key: "count",      label: "Bubble Amount",min: 0.1, max: 2.0, step: 0.05, def: 1.0 },
        { key: "popSpark",   label: "Pop Sparkle",  min: 0, max: 1, step: 0.01, def: 0.6 },
        { key: "wiggle",     label: "Wiggle",       min: 0, max: 1, step: 0.01, def: 0.35 },
      ],
      onDown(x,y){ spawnBubble(x,y, 1.2); },
      onMove(x,y,meta){
        const amt = p("count");
        meta.bAcc = (meta.bAcc || 0) + meta.dist * 0.02 * amt;
        while (meta.bAcc > 1) {
          meta.bAcc -= 1;
          spawnBubble(x,y, 1.0);
        }
      },
      drawBackground(){ drawSoftBackground(); },
      drawOverlay(){ /* no trail by default */ }
    },

    {
      id: "ribbon",
      name: "üåà Rainbow Ribbon",
      sliders: [
        { key: "width",    label: "Ribbon Width",   min: 6, max: 40, step: 1, def: 20 },
        { key: "spring",   label: "Springiness",    min: 0.02, max: 0.25, step: 0.01, def: 0.10 },
        { key: "smooth",   label: "Smoothness",     min: 0.05, max: 0.55, step: 0.01, def: 0.22 },
        { key: "glitter",  label: "Glitter",        min: 0, max: 1, step: 0.01, def: 0.35 },
        { key: "fade",     label: "Fade Speed",     min: 0.2, max: 2.5, step: 0.05, def: 1.0 },
      ],
      onDown(x,y,meta){
        ensureRibbon(meta.pointerId, x, y);
        burstSparkles(x,y, 10);
      },
      onMove(x,y,meta){
        ensureRibbon(meta.pointerId, x, y);
        if (p("glitter") > 0.01 && meta.speed > 2) {
          burstSparkles(x,y, Math.floor(clamp(meta.speed/2, 2, 10) * p("glitter")));
        }
      },
      onUp(_,__,meta){ /* let it fade naturally */ },
      drawBackground(){ drawSoftBackground(); },
      drawOverlay(){ drawRibbons(); }
    },
  ];

  // Active effect + params storage
  let activeEffectId = effects[0].id;
  const effectParams = Object.fromEntries(effects.map(e => [e.id, Object.fromEntries(e.sliders.map(s => [s.key, s.def]))]));
  function p(key){ return effectParams[activeEffectId][key]; }

  // Populate select
  for (const e of effects) {
    const opt = document.createElement("option");
    opt.value = e.id;
    opt.textContent = e.name;
    effectSelect.appendChild(opt);
  }
  effectSelect.value = activeEffectId;

  function setEffect(id) {
    activeEffectId = id;
    buildSliders();
    pokeUI();
    // friendly ‚Äúburst‚Äù on effect switch (fun feedback)
    const x = innerWidth * 0.5, y = innerHeight * 0.35;
    burstStars(x, y, 24, 1.0);
  }

  effectSelect.onchange = () => setEffect(effectSelect.value);

  function buildSliders() {
    slidersEl.innerHTML = "";
    const effect = effects.find(e => e.id === activeEffectId);
    for (const s of effect.sliders) {
      const wrap = document.createElement("div");
      wrap.className = "slider";

      const left = document.createElement("div");
      const label = document.createElement("label");
      label.textContent = s.label;
      const range = document.createElement("input");
      range.type = "range";
      range.min = s.min; range.max = s.max; range.step = s.step;
      range.value = effectParams[activeEffectId][s.key];

      left.appendChild(label);
      left.appendChild(range);

      const val = document.createElement("div");
      val.className = "value";
      val.textContent = fmt(Number(range.value), s.step);

      range.oninput = () => {
        effectParams[activeEffectId][s.key] = Number(range.value);
        val.textContent = fmt(Number(range.value), s.step);
        pokeUI();
      };

      wrap.appendChild(left);
      wrap.appendChild(val);
      slidersEl.appendChild(wrap);
    }
  }
  buildSliders();

  // ---------- Input handling (multi-touch) ----------
  const pointers = new Map(); // id -> {x,y,px,py}
  const perPointerMeta = new Map(); // id -> effect-specific meta (accumulators etc.)
  const state = {
    particles: [],
    blobs: [],
    bubbles: [],
    trails: new Map(),   // id -> points
    ribbons: new Map(),  // id -> ribbon object
  };

  // Avoid painting when touching UI:
  function isOverUI(target) {
    return target.closest && target.closest("#panel");
  }

  canvas.addEventListener("pointerdown", (e) => {
    if (isOverUI(e.target)) return;
    canvas.setPointerCapture(e.pointerId);

    const x = e.clientX, y = e.clientY;
    pointers.set(e.pointerId, { x, y, px: x, py: y });
    perPointerMeta.set(e.pointerId, { pointerId: e.pointerId });

    // Trail points (used by some effects)
    state.trails.set(e.pointerId, [{ x, y, t: performance.now() }]);

    pokeUI();
    callEffectHandler("onDown", x, y, e.pointerId, 0, 0, 0);
    e.preventDefault();
  }, { passive: false });

  canvas.addEventListener("pointermove", (e) => {
    const pnt = pointers.get(e.pointerId);
    if (!pnt) return;

    const x = e.clientX, y = e.clientY;
    const vx = x - pnt.x;
    const vy = y - pnt.y;
    const dist = Math.hypot(vx, vy);
    const speed = dist; // pixels per move; good enough for ‚Äúfeel‚Äù

    pnt.px = pnt.x; pnt.py = pnt.y;
    pnt.x = x; pnt.y = y;

    // Update trail with smoothing
    const tr = state.trails.get(e.pointerId);
    if (tr) {
      const last = tr[tr.length - 1];
      const dx = x - last.x, dy = y - last.y;
      const d = Math.hypot(dx, dy);
      const steps = Math.floor(d / 10);
      const now = performance.now();
      for (let i=1; i<=steps; i++) {
        const tt = i/(steps+1);
        tr.push({ x: last.x + dx*tt, y: last.y + dy*tt, t: now });
      }
      tr.push({ x, y, t: now });
      while (tr.length > 42) tr.shift();
    }

    pokeUI();
    callEffectHandler("onMove", x, y, e.pointerId, speed, dist, 0);
    e.preventDefault();
  }, { passive: false });

  function endPointer(e) {
    if (!pointers.has(e.pointerId)) return;
    const pnt = pointers.get(e.pointerId);
    pointers.delete(e.pointerId);

    callEffectHandler("onUp", pnt?.x ?? 0, pnt?.y ?? 0, e.pointerId, 0, 0, 0);

    // let trails/ribbons fade; cleanup later
    setTimeout(() => {
      state.trails.delete(e.pointerId);
      perPointerMeta.delete(e.pointerId);
      // ribbons are kept to fade (handled in drawRibbons)
    }, 900);
  }
  canvas.addEventListener("pointerup", endPointer, { passive: true });
  canvas.addEventListener("pointercancel", endPointer, { passive: true });

  function callEffectHandler(method, x, y, pointerId, speed, dist, dt) {
    const effect = effects.find(e => e.id === activeEffectId);
    const meta = perPointerMeta.get(pointerId) || { pointerId };
    meta.speed = speed;
    meta.dist = dist;
    meta.dt = dt;
    perPointerMeta.set(pointerId, meta);

    if (effect && typeof effect[method] === "function") {
      effect[method](x, y, meta);
    }
  }

  // ---------- Visual systems ----------
  // Sparkle dots
  function burstSparkles(x,y,count) {
    for (let i=0;i<count;i++) {
      const a = rand(0, Math.PI*2);
      const s = rand(0.6, 4.2);
      state.particles.push({
        kind: "sparkle",
        x, y,
        vx: Math.cos(a)*s,
        vy: Math.sin(a)*s,
        r: rand(1.2, 3.2),
        life: rand(0.25, 0.9),
        hue: rand(40, 70),
        tw: rand(0, Math.PI*2),
      });
    }
  }

  // Star ‚Äúconfetti‚Äù (tiny stars)
  function burstStars(x,y,count,scale=1) {
    for (let i=0;i<count;i++) {
      const a = rand(0, Math.PI*2);
      const s = rand(0.8, 4.6) * scale;
      state.particles.push({
        kind: "tinyStar",
        x, y,
        vx: Math.cos(a)*s,
        vy: Math.sin(a)*s,
        size: rand(3, 8) * scale,
        rot: rand(0, Math.PI*2),
        vr: rand(-3, 3),
        life: rand(0.35, 1.1),
        hue: rand(40, 80),
      });
    }
  }

  // Goo blobs
  function dropBlob(x,y,meta,strength=1) {
    const base = (effectParams[activeEffectId]?.size ?? 24);
    state.blobs.push({
      x, y,
      r: rand(base*0.55, base*1.15) * strength,
      vx: rand(-0.9, 0.9) * strength,
      vy: rand(-0.9, 0.9) * strength,
      life: rand(0.7, 1.5),
      hue: rand(260, 320),
    });
    if ((meta?.speed ?? 0) > 10) {
      // little extra delight when moving fast
      burstStars(x,y, 2, 0.7);
    }
  }

  // Burst star stamps (big star shape)
  function spawnBurstStar(x,y,scale=1) {
    const points = Math.round(p("points"));
    const radius = p("radius") * scale;
    const wobble = p("wobble");
    const hue = rand(35, 70);
    state.particles.push({
      kind: "bigStar",
      x, y,
      points,
      radius,
      inner: radius * rand(0.35, 0.55),
      wobble,
      rot: rand(0, Math.PI*2),
      vr: rand(-1.5, 1.5),
      life: rand(0.45, 1.3),
      hue,
    });
  }

  // Firework pop (many particles with chosen size/count)
  function fireworkPop(x,y,scale=1) {
    const count = Math.round(p("count"));
    const spread = p("spread");
    const popSize = p("pop") * scale;
    for (let i=0;i<count;i++) {
      const a = rand(0, Math.PI*2);
      const sp = rand(0.8, 6.0) * spread;
      state.particles.push({
        kind: "fw",
        x, y,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp,
        r: rand(1.2, 3.0) * (popSize/48),
        life: rand(0.35, 1.0),
        hue: rand(180, 330),
        glow: p("glow"),
      });
    }
    burstStars(x,y, 10, 1.0);
  }

  // Bubbles
  function spawnBubble(x,y,scale=1) {
    const sz = p("bubbleSize") * scale;
    state.bubbles.push({
      x, y,
      r: rand(sz*0.7, sz*1.1),
      vy: rand(-1.0, -2.2) * p("rise"),
      vx: rand(-0.4, 0.4),
      life: rand(1.2, 2.6),
      phase: rand(0, Math.PI*2),
    });
  }

  // Ribbon system
  function ensureRibbon(pointerId, x, y) {
    if (!state.ribbons.has(pointerId)) {
      state.ribbons.set(pointerId, {
        x, y, vx: 0, vy: 0,
        points: [{x,y,a:1}],
        hue: rand(0, 360),
      });
    }
    const r = state.ribbons.get(pointerId);
    if (!r) return;
    r.targetX = x;
    r.targetY = y;
  }

  // ---------- Drawing helpers ----------
  function drawSoftBackground() {
    ctx.clearRect(0, 0, innerWidth, innerHeight);
    ctx.fillStyle = "#050510";
    ctx.fillRect(0, 0, innerWidth, innerHeight);

    // subtle ‚Äúnight glow‚Äù
    const g = ctx.createRadialGradient(innerWidth*0.5, innerHeight*0.35, 30, innerWidth*0.5, innerHeight*0.35, Math.max(innerWidth, innerHeight)*0.7);
    g.addColorStop(0, "rgba(180,120,255,0.10)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,innerWidth,innerHeight);
  }

  function drawVignette() {
    const grad = ctx.createRadialGradient(innerWidth/2, innerHeight/2, Math.min(innerWidth, innerHeight)*0.2,
                                         innerWidth/2, innerHeight/2, Math.max(innerWidth, innerHeight)*0.75);
    grad.addColorStop(0, "rgba(0,0,0,0)");
    grad.addColorStop(1, "rgba(0,0,0,0.35)");
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,innerWidth,innerHeight);
  }

  function drawTrails(alpha=0.12) {
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (const pts of state.trails.values()) {
      if (!pts || pts.length < 2) continue;
      const age = performance.now() - pts[pts.length - 1].t;
      const a = clamp(1 - age / 900, 0, 1);
      if (a <= 0) continue;

      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.lineWidth = 18;
      ctx.strokeStyle = `rgba(120, 220, 255, ${alpha * a})`;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawGoo() {
    const blur = effectParams[activeEffectId]?.blur ?? 12;
    gtx.clearRect(0, 0, innerWidth, innerHeight);
    gtx.save();
    gtx.filter = `blur(${Math.max(0, blur)}px)`;
    gtx.globalCompositeOperation = "lighter";

    for (const b of state.blobs) {
      const a = clamp(b.life, 0, 1) * 0.9;
      gtx.fillStyle = `hsla(${b.hue}, 95%, 65%, ${a})`;
      gtx.beginPath();
      gtx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      gtx.fill();
    }
    gtx.restore();

    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.drawImage(gooCanvas, 0, 0, innerWidth, innerHeight);
    ctx.restore();

    // shiny highlights
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "white";
    for (const b of state.blobs) {
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.25, b.y - b.r*0.25, b.r*0.35, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawBigStar(x,y,points,rOuter,rInner,rot,fillStyle,alpha=1) {
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(rot);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = fillStyle;

    ctx.beginPath();
    for (let i=0;i<points*2;i++) {
      const r = (i%2===0) ? rOuter : rInner;
      const a = (i/(points*2)) * Math.PI*2;
      ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
    }
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawBubbles() {
    ctx.save();
    for (const b of state.bubbles) {
      const a = clamp(b.life/0.6, 0, 1) * 0.7;
      ctx.globalAlpha = a;
      // outer
      ctx.strokeStyle = "rgba(200,240,255,0.55)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.stroke();
      // inner shine
      ctx.globalAlpha = a * 0.5;
      ctx.fillStyle = "rgba(255,255,255,0.35)";
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.25, b.y - b.r*0.25, b.r*0.25, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = a;
    }
    ctx.restore();
  }

  function drawRibbons() {
    // Each pointer ribbon is a spring toward its target; points fade over time
    ctx.save();
    ctx.globalCompositeOperation = "lighter";

    for (const [id, r] of state.ribbons.entries()) {
      if (!r) continue;

      const spring = p("spring");
      const smooth = p("smooth");
      const fade = p("fade");

      if (r.targetX != null) {
        const ax = (r.targetX - r.x) * spring;
        const ay = (r.targetY - r.y) * spring;
        r.vx = (r.vx + ax) * (1 - smooth);
        r.vy = (r.vy + ay) * (1 - smooth);
        r.x += r.vx * 60 * dtGlobal;
        r.y += r.vy * 60 * dtGlobal;

        r.points.push({ x: r.x, y: r.y, a: 1 });
        while (r.points.length > 60) r.points.shift();
      }

      // fade points
      for (const pt of r.points) pt.a -= dtGlobal * fade * 0.8;
      while (r.points.length && r.points[0].a <= 0) r.points.shift();

      if (r.points.length < 2) continue;

      const w = p("width");
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.lineWidth = w;

      // draw in segments with shifting hue
      ctx.beginPath();
      ctx.moveTo(r.points[0].x, r.points[0].y);
      for (let i=1;i<r.points.length;i++) ctx.lineTo(r.points[i].x, r.points[i].y);

      // Use a gradient-ish stroke by drawing twice:
      ctx.strokeStyle = `hsla(${r.hue}, 95%, 70%, 0.22)`;
      ctx.stroke();
      ctx.lineWidth = Math.max(2, w*0.55);
      ctx.strokeStyle = `hsla(${(r.hue+60)%360}, 95%, 75%, 0.28)`;
      ctx.stroke();

      r.hue = (r.hue + dtGlobal * 90) % 360;

      // cleanup ribbon if inactive pointer and fully faded
      if (!pointers.has(id) && r.points.length === 0) state.ribbons.delete(id);
    }

    ctx.restore();
  }

  // ---------- Update loop ----------
  let last = performance.now();
  let dtGlobal = 0.016;

  function update(dt) {
    // blobs
    for (let i=state.blobs.length-1;i>=0;i--) {
      const b = state.blobs[i];
      b.life -= dt;
      b.x += b.vx * 60 * dt;
      b.y += b.vy * 60 * dt;
      b.vx *= (1 - 1.8 * dt);
      b.vy *= (1 - 1.8 * dt);

      const grav = effectParams[activeEffectId]?.gravity ?? -0.25;
      b.vy += grav * dt; // negative = float up

      b.r *= (0.996 + 0.002 * clamp(b.life/0.35,0,1));
      if (b.life <= 0 || b.r < 2) state.blobs.splice(i,1);
    }

    // bubbles
    for (let i=state.bubbles.length-1;i>=0;i--) {
      const b = state.bubbles[i];
      b.life -= dt;
      b.phase += dt * (0.8 + p("wiggle")*3.0);
      b.x += (b.vx + Math.sin(b.phase) * 0.8 * p("wiggle")) * 60 * dt;
      b.y += b.vy * 60 * dt;

      // pop at top or end of life
      if (b.y + b.r < -10 || b.life <= 0) {
        if (p("popSpark") > 0.01) burstSparkles(b.x, b.y, Math.floor(16 * p("popSpark")));
        burstStars(b.x, b.y, 8, 0.8);
        state.bubbles.splice(i,1);
      }
    }

    // particles
    for (let i=state.particles.length-1;i>=0;i--) {
      const pt = state.particles[i];
      pt.life -= dt;

      if (pt.kind === "sparkle") {
        pt.x += pt.vx * 60 * dt;
        pt.y += pt.vy * 60 * dt;
        pt.vx *= (1 - 2.2 * dt);
        pt.vy *= (1 - 2.2 * dt);
        pt.vy += 0.8 * dt;
        pt.tw += 10 * dt;
      } else if (pt.kind === "tinyStar") {
        pt.x += pt.vx * 60 * dt;
        pt.y += pt.vy * 60 * dt;
        pt.vx *= (1 - 1.8 * dt);
        pt.vy *= (1 - 1.8 * dt);
        pt.vy += 0.7 * dt;
        pt.rot += pt.vr * dt;
      } else if (pt.kind === "bigStar") {
        pt.rot += pt.vr * dt;
      } else if (pt.kind === "fw") {
        const drag = p("drag") ?? 0.10;
        pt.x += pt.vx * 60 * dt;
        pt.y += pt.vy * 60 * dt;
        pt.vx *= (1 - drag);
        pt.vy *= (1 - drag);
        pt.vy += 0.9 * dt;
      }

      if (pt.life <= 0) state.particles.splice(i,1);
    }

    // toddler mode auto-hide
    if (toddlerMode) {
      const idle = performance.now() - lastInteractionAt;
      if (idle > UI_HIDE_MS) {
        panel.classList.add("hidden");
        hint.classList.add("hidden");
      }
    }
  }

  function draw() {
    const effect = effects.find(e => e.id === activeEffectId);
    (effect?.drawBackground || drawSoftBackground)();

    // Some effects use goo
    if (activeEffectId === "sparklyGoo" && p("goo") > 0.01) drawGoo();

    // bubbles
    if (activeEffectId === "bubbles") drawBubbles();

    // overlay trails/ribbons
    effect?.drawOverlay?.();

    // draw particles
    ctx.save();
    ctx.globalCompositeOperation = "lighter";

    for (const pt of state.particles) {
      if (pt.kind === "sparkle") {
        const a = clamp(pt.life / 0.35, 0, 1);
        const tw = 0.6 + 0.4 * Math.sin(pt.tw);
        ctx.fillStyle = `hsla(${pt.hue}, 95%, 70%, ${a * tw})`;
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, pt.r * (0.7 + tw), 0, Math.PI*2);
        ctx.fill();
      } else if (pt.kind === "tinyStar") {
        const a = clamp(pt.life / 0.35, 0, 1);
        drawBigStar(pt.x, pt.y, 5, pt.size, pt.size*0.5, pt.rot, `hsla(${pt.hue},95%,70%,${a})`, 1);
      } else if (pt.kind === "bigStar") {
        const a = clamp(pt.life / 0.45, 0, 1);
        const wob = pt.wobble;
        const rr = pt.radius * (1 + Math.sin(performance.now()*0.003 + pt.rot) * 0.08 * wob);
        const ri = pt.inner  * (1 + Math.cos(performance.now()*0.003 + pt.rot) * 0.10 * wob);
        drawBigStar(pt.x, pt.y, pt.points, rr, ri, pt.rot, `hsla(${pt.hue},95%,68%,${a})`, 1);
        // soft glow ring
        ctx.globalAlpha = a * 0.25;
        ctx.strokeStyle = `hsla(${pt.hue},95%,80%,1)`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, rr*0.75, 0, Math.PI*2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      } else if (pt.kind === "fw") {
        const a = clamp(pt.life / 0.35, 0, 1) * (pt.glow ?? 0.8);
        ctx.fillStyle = `hsla(${pt.hue}, 95%, 70%, ${a})`;
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, pt.r * (0.7 + a), 0, Math.PI*2);
        ctx.fill();
      }
    }
    ctx.restore();

    drawVignette();
  }

  function frame(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    dtGlobal = dt;
    last = now;

    // Let effects use dt in per-pointer meta
    for (const [id, meta] of perPointerMeta.entries()) meta.dt = dt;

    update(dt);
    draw();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // start effect
  setEffect(activeEffectId);
})();
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Touchy Effects (v2)</title>
  <style>
    html, body {
      margin: 0; height: 100%;
      background: #050510;
      overflow: hidden;
      touch-action: none;
    }
    canvas { display:block; width:100vw; height:100vh; }

    /* Top-left arrow button */
    .toggleBtn {
      position: fixed;
      left: 12px; top: 12px;
      width: 48px; height: 48px;
      border: 0;
      border-radius: 16px;
      z-index: 20;

      background: rgba(255,255,255,0.14);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      color: rgba(255,255,255,0.92);

      font: 900 22px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      display: grid;
      place-items: center;
      user-select: none;
      -webkit-user-select: none;
    }
    .toggleBtn:active { transform: scale(0.98); }

    /* Collapsible settings pane */
    .pane {
      position: fixed;
      left: 12px; top: 68px;
      width: min(420px, calc(100vw - 24px));
      z-index: 20;

      background: rgba(255,255,255,0.10);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-radius: 18px;
      padding: 12px;

      color: rgba(255,255,255,0.92);
      font: 700 15px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;

      box-shadow: 0 10px 24px rgba(0,0,0,0.35);
      user-select: none;
      -webkit-user-select: none;

      transform-origin: top left;
      transition: transform 220ms ease, opacity 220ms ease;
    }
    .pane.closed {
      opacity: 0;
      transform: scale(0.95);
      pointer-events: none;
    }

    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom: 10px; }
    button, select {
      font: 800 15px/1.1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      padding: 10px 12px;
      border: 0;
      border-radius: 14px;
      background: rgba(255,255,255,0.14);
      color: rgba(255,255,255,0.95);
      outline: none;
    }
    button:active { transform: scale(0.98); }
    select { flex: 1; min-width: 220px; }

    .toggle {
      display:flex; align-items:center; justify-content:space-between;
      gap: 10px;
      background: rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 10px 12px;
    }
    .toggle .sub {
      font-weight: 650;
      font-size: 12px;
      color: rgba(255,255,255,0.70);
      margin-top: 4px;
    }
    .switch {
      width: 52px; height: 30px;
      border-radius: 999px;
      background: rgba(255,255,255,0.18);
      position: relative;
      flex: 0 0 auto;
    }
    .switch::after {
      content:"";
      position:absolute; top: 4px; left: 4px;
      width: 22px; height: 22px;
      border-radius: 999px;
      background: rgba(255,255,255,0.88);
      transition: transform 160ms ease;
    }
    .switch.on { background: rgba(140, 255, 210, 0.24); }
    .switch.on::after { transform: translateX(22px); }

    .sliders {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 6px;
    }
    .slider {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      background: rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 10px 12px;
    }
    .slider label {
      display: block;
      font-weight: 800;
      font-size: 13px;
      color: rgba(255,255,255,0.85);
      margin-bottom: 6px;
    }
    .slider .value {
      font-size: 12px;
      font-weight: 800;
      color: rgba(255,255,255,0.75);
      min-width: 64px;
      text-align: right;
    }
    input[type="range"] { width: 100%; accent-color: rgba(255,255,255,0.9); }

    /* Subtle hint */
    .hint {
      position: fixed; right: 12px; top: 12px;
      z-index: 10;
      font: 700 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: rgba(255,255,255,0.70);
      background: rgba(255,255,255,0.08);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 10px 12px;
      border-radius: 14px;
      user-select: none;
      -webkit-user-select: none;
      transition: opacity 220ms ease;
    }
    .hint.hidden { opacity: 0; }
    /* Let the settings UI handle touches normally */
    #pane, #pane * {
    touch-action: manipulation; /* or: auto */
    }
  </style>
</head>
<body>
  <button id="paneToggle" class="toggleBtn" aria-label="Settings">‚ùÆ</button>

  <div id="pane" class="pane closed">
    <div class="row">
      <button id="clearBtn">Clear</button>
      <button id="randomizeBtn" title="Gently randomize current effect sliders">Shuffle</button>
    </div>

    <div class="row">
      <select id="effectSelect"></select>
    </div>

    <div class="toggle" id="soundToggle">
      <div>
        Sound
        <div class="sub">Soft chimes + pops (starts after first touch)</div>
      </div>
      <div class="switch" id="soundSwitch"></div>
    </div>

    <div class="toggle" id="autoSlidersToggle" style="margin-top:10px;">
      <div>
        Auto-modulate sliders
        <div class="sub">Values drift while you play</div>
      </div>
      <div class="switch" id="autoSlidersSwitch"></div>
    </div>

    <div class="toggle" id="autoCycleToggle" style="margin-top:10px;">
      <div>
        Auto-cycle effects
        <div class="sub">Switch effects every few seconds</div>
      </div>
      <div class="switch" id="autoCycleSwitch"></div>
    </div>

    <div class="sliders" id="sliders"></div>
  </div>

  <div id="hint" class="hint">Touch & drag ‚ú® (multi-touch works)</div>
  <canvas id="c"></canvas>

<script>
(() => {
  // ---------------- Canvas setup ----------------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: true });

  const gooCanvas = document.createElement("canvas");
  const gtx = gooCanvas.getContext("2d", { alpha: true });

  function resize() {
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";

    gooCanvas.width = canvas.width;
    gooCanvas.height = canvas.height;

    // Draw in CSS pixels
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    gtx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener("resize", resize, { passive: true });
  resize();

  // ---------------- Helpers ----------------
  const rand = (a,b)=>a+Math.random()*(b-a);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;

  function fmt(v, step) {
    const s = step || 1;
    const d = (s < 1) ? (String(s).split(".")[1]?.length || 0) : 0;
    return Number(v).toFixed(d);
  }

  // ---------------- UI: collapsible pane ----------------
  const pane = document.getElementById("pane");
  const hint = document.getElementById("hint");
  const paneToggle = document.getElementById("paneToggle");

  let paneOpen = false;
  function setPaneOpen(open) {
    paneOpen = open;
    pane.classList.toggle("closed", !open);
    paneToggle.textContent = open ? "‚ùØ" : "‚ùÆ";
    canvas.style.pointerEvents = open ? "none" : "auto";
  }
  paneToggle.onclick = (e) => {
    e.stopPropagation();
    setPaneOpen(!paneOpen);
  };

  // Prevent pane interaction from painting:
  pane.addEventListener("pointerdown", (e) => e.stopPropagation(), { passive: true });
  pane.addEventListener("pointermove", (e) => e.stopPropagation(), { passive: true });

  // Tap canvas hides hint after a bit:
  let hintTimer = 0;

  // ---------------- Sound (Web Audio) ----------------
  let audioCtx = null;
  let soundEnabled = true;
  let audioPrimed = false;

  function ensureAudio() {
    if (!soundEnabled) return;
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
    audioPrimed = true;
  }

  function playTone(freq, dur=0.08, type="sine", vol=0.05) {
    if (!soundEnabled) return;
    if (!audioPrimed) return; // wait for first gesture
    const t0 = audioCtx.currentTime;

    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    o.type = type;
    o.frequency.setValueAtTime(freq, t0);

    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

    o.connect(g);
    g.connect(audioCtx.destination);

    o.start(t0);
    o.stop(t0 + dur + 0.02);
  }

  function playPop(intensity=1) {
    // short, soft ‚Äúpop‚Äù
    const f = lerp(180, 420, clamp(intensity, 0, 1));
    playTone(f, 0.06, "triangle", 0.045);
  }
  function playChime(intensity=1) {
    // two-note chime
    const base = lerp(420, 860, clamp(intensity, 0, 1));
    playTone(base, 0.08, "sine", 0.04);
    setTimeout(() => playTone(base*1.25, 0.07, "sine", 0.03), 25);
  }
  

  // ---------------- Toggles in pane ----------------
  function hookSwitch(containerId, switchId, getter, setter) {
    const row = document.getElementById(containerId);
    const sw = document.getElementById(switchId);
    function sync() { sw.classList.toggle("on", !!getter()); }
    row.addEventListener("click", () => { setter(!getter()); sync(); }, { passive: true });
    sync();
    return sync;
  }

  const soundSync = hookSwitch("soundToggle", "soundSwitch",
    () => soundEnabled,
    (v) => { soundEnabled = v; if (!v) return; if (audioCtx) ensureAudio(); }
  );

  let autoSliders = true;
  const autoSlidersSync = hookSwitch("autoSlidersToggle", "autoSlidersSwitch", () => autoSliders, (v) => autoSliders = v);

  let autoCycle = false;
  const autoCycleSync = hookSwitch("autoCycleToggle", "autoCycleSwitch", () => autoCycle, (v) => autoCycle = v);

  // ---------------- Effect system ----------------
  const slidersEl = document.getElementById("sliders");
  const effectSelect = document.getElementById("effectSelect");

  const effects = [
    {
      id: "sparklyGoo",
      name: "‚ú® Sparkly Goo",
      sliders: [
        { key:"goo", label:"Goo Amount", min:0, max:1, step:0.01, def:1, mod:0.20 },
        { key:"sparkle", label:"Sparkle Amount", min:0, max:1, step:0.01, def:1, mod:0.22 },
        { key:"size", label:"Blob Size", min:10, max:44, step:1, def:24, mod:0.12 },
        { key:"blur", label:"Goo Blur", min:0, max:26, step:1, def:12, mod:0.10 },
        { key:"float", label:"Floatiness", min:-1.2, max:1.2, step:0.05, def:-0.35, mod:0.14 },
      ],
      onDown(x,y,meta){ burstStars(x,y, 18, 0.8); dropBlob(x,y, meta, 1.3); playChime(0.5); },
      onMove(x,y,meta){
        const speed = meta.speed;
        if (p("goo") > 0.01) dropBlob(x,y, meta, clamp(speed/14, 0.6, 2.0) * p("goo"));
        if (p("sparkle") > 0.01 && speed > 1.5) {
          burstSparkles(x,y, Math.floor(clamp(speed/2, 2, 14) * p("sparkle")));
          if (speed > 10) playTone(lerp(320, 760, clamp(speed/28,0,1)), 0.04, "sine", 0.02);
        }
      },
      drawOverlay(){ drawTrails(0.16); drawGoo(p("blur")); },
    },
    {
      id: "starBursts",
      name: "‚≠ê Star Bursts",
      sliders: [
        { key:"rate", label:"Burst Rate", min:0.1, max:2.0, step:0.05, def:1.0, mod:0.18 },
        { key:"points", label:"Star Points", min:4, max:10, step:1, def:5, mod:0.10 },
        { key:"radius", label:"Star Size", min:10, max:70, step:1, def:28, mod:0.15 },
        { key:"glitter", label:"Glitter", min:0, max:1, step:0.01, def:0.7, mod:0.22 },
        { key:"wobble", label:"Wobble", min:0, max:1, step:0.01, def:0.5, mod:0.20 },
      ],
      onDown(x,y){ spawnBurstStar(x,y, 1.0); playChime(0.6); },
      onMove(x,y,meta){
        const rate = p("rate");
        meta.emitAcc = (meta.emitAcc || 0) + meta.dist * 0.02 * rate;
        while (meta.emitAcc > 1) {
          meta.emitAcc -= 1;
          spawnBurstStar(x,y, 0.75);
          if (p("glitter") > 0.2) playTone(rand(520, 980), 0.03, "triangle", 0.02);
        }
        if (p("glitter") > 0.01 && meta.speed > 2) burstSparkles(x,y, Math.floor(clamp(meta.speed, 0, 12) * p("glitter")));
      },
      drawOverlay(){ drawTrails(0.10); }
    },
    {
      id: "fireworks",
      name: "üéÜ Fireworks Paint",
      sliders: [
        { key:"pop", label:"Pop Size", min:10, max:90, step:1, def:48, mod:0.18 },
        { key:"count", label:"Particles", min:10, max:90, step:1, def:34, mod:0.12 },
        { key:"spread", label:"Spread", min:0.3, max:3.0, step:0.05, def:1.2, mod:0.16 },
        { key:"drag", label:"Air Drag", min:0.0, max:0.25, step:0.01, def:0.10, mod:0.12 },
        { key:"glow", label:"Glow", min:0, max:1, step:0.01, def:0.85, mod:0.20 },
      ],
      onDown(x,y){ fireworkPop(x,y, 1.0); playPop(0.8); },
      onMove(x,y,meta){
        meta.popTimer = (meta.popTimer || 0) - meta.dt;
        const interval = lerp(0.22, 0.05, clamp(meta.speed/18, 0, 1));
        if (meta.popTimer <= 0) {
          meta.popTimer = interval;
          fireworkPop(x,y, 0.9);
          playPop(clamp(meta.speed/18,0,1));
        }
      },
      drawOverlay(){ drawTrails(0.08); }
    },
    {
      id: "bubbles",
      name: "ü´ß Bubbles & Pops",
      sliders: [
        { key:"bubbleSize", label:"Bubble Size", min:10, max:80, step:1, def:34, mod:0.14 },
        { key:"rise", label:"Rise Speed", min:0.2, max:2.4, step:0.05, def:1.0, mod:0.16 },
        { key:"amount", label:"Bubble Amount", min:0.1, max:2.2, step:0.05, def:1.0, mod:0.18 },
        { key:"popSpark", label:"Pop Sparkle", min:0, max:1, step:0.01, def:0.6, mod:0.22 },
        { key:"wiggle", label:"Wiggle", min:0, max:1, step:0.01, def:0.35, mod:0.18 },
      ],
      onDown(x,y){ spawnBubble(x,y, 1.2); playTone(260, 0.05, "sine", 0.03); },
      onMove(x,y,meta){
        const amt = p("amount");
        meta.bAcc = (meta.bAcc || 0) + meta.dist * 0.02 * amt;
        while (meta.bAcc > 1) {
          meta.bAcc -= 1;
          spawnBubble(x,y, 1.0);
          if (Math.random() < 0.15) playTone(rand(220, 340), 0.03, "sine", 0.015);
        }
      },
      drawOverlay(){ drawBubbles(); }
    },
    {
      id: "ribbon",
      name: "üåà Rainbow Ribbon",
      sliders: [
        { key:"width", label:"Ribbon Width", min:6, max:44, step:1, def:20, mod:0.15 },
        { key:"spring", label:"Springiness", min:0.02, max:0.25, step:0.01, def:0.10, mod:0.14 },
        { key:"smooth", label:"Smoothness", min:0.05, max:0.55, step:0.01, def:0.22, mod:0.14 },
        { key:"glitter", label:"Glitter", min:0, max:1, step:0.01, def:0.35, mod:0.22 },
        { key:"fade", label:"Fade Speed", min:0.2, max:2.5, step:0.05, def:1.0, mod:0.12 },
      ],
      onDown(x,y,meta){ ensureRibbon(meta.pointerId, x, y); burstSparkles(x,y, 10); playChime(0.55); },
      onMove(x,y,meta){
        ensureRibbon(meta.pointerId, x, y);
        if (p("glitter") > 0.01 && meta.speed > 2) {
          burstSparkles(x,y, Math.floor(clamp(meta.speed/2, 2, 10) * p("glitter")));
          if (meta.speed > 9) playTone(rand(520, 1000), 0.025, "sine", 0.015);
        }
      },
      drawOverlay(){ drawRibbons(); }
    },
  ];

  let activeEffectId = effects[0].id;
  const effectParams = Object.fromEntries(
    effects.map(e => [e.id, Object.fromEntries(e.sliders.map(s => [s.key, s.def]))])
  );
  function p(key){ return effectParams[activeEffectId][key]; }

  // Build effect select
  for (const e of effects) {
    const opt = document.createElement("option");
    opt.value = e.id;
    opt.textContent = e.name;
    effectSelect.appendChild(opt);
  }
  effectSelect.value = activeEffectId;

  function buildSliders() {
    slidersEl.innerHTML = "";
    const effect = effects.find(e => e.id === activeEffectId);

    for (const s of effect.sliders) {
      const wrap = document.createElement("div");
      wrap.className = "slider";

      const left = document.createElement("div");
      const label = document.createElement("label");
      label.textContent = s.label;

      const range = document.createElement("input");
      range.type = "range";
      range.min = s.min; range.max = s.max; range.step = s.step;
      range.value = effectParams[activeEffectId][s.key];

      left.appendChild(label);
      left.appendChild(range);

      const val = document.createElement("div");
      val.className = "value";
      val.textContent = fmt(Number(range.value), s.step);

      range.oninput = () => {
        effectParams[activeEffectId][s.key] = Number(range.value);
        val.textContent = fmt(Number(range.value), s.step);
      };

      wrap.appendChild(left);
      wrap.appendChild(val);
      slidersEl.appendChild(wrap);
    }
  }

  function setEffect(id) {
    activeEffectId = id;
    effectSelect.value = id;
    buildSliders();

    // friendly feedback
    const x = innerWidth * 0.5, y = innerHeight * 0.33;
    burstStars(x, y, 24, 1.0);
    if (soundEnabled) playChime(0.75);
  }

  effectSelect.onchange = () => setEffect(effectSelect.value);

  // Buttons
  document.getElementById("clearBtn").onclick = () => {
    state.particles.length = 0;
    state.blobs.length = 0;
    state.bubbles.length = 0;
    state.trails.clear();
    state.ribbons.clear();
  };

  document.getElementById("randomizeBtn").onclick = () => {
    gentleShuffleSliders(activeEffectId);
    buildSliders();
    burstStars(innerWidth*0.5, innerHeight*0.3, 18, 0.9);
    playChime(0.65);
  };

  function gentleShuffleSliders(effectId) {
    const effect = effects.find(e => e.id === effectId);
    for (const s of effect.sliders) {
      const v = effectParams[effectId][s.key];
      const t = rand(-1, 1) * (s.max - s.min) * 0.06;
      effectParams[effectId][s.key] = clamp(v + t, s.min, s.max);
    }
  }

  // ---------------- Input handling ----------------
  const pointers = new Map();       // id -> {x,y}
  const perPointerMeta = new Map(); // id -> {pointerId, emitAcc, ...}

  const state = {
    particles: [],
    blobs: [],
    bubbles: [],
    trails: new Map(),
    ribbons: new Map(),
  };

  function isOverUI(target) {
    return target.closest && (target.closest("#pane") || target.closest("#paneToggle"));
  }

  canvas.addEventListener("pointerdown", (e) => {
    if (isOverUI(e.target)) return;

    // Prime audio on first gesture (required on iOS)
    if (!audioPrimed && soundEnabled) {
      ensureAudio();
      // tiny ‚Äúhello‚Äù chime
      playChime(0.35);
    }

    hintTimer = 2.0;
    hint.classList.add("hidden");

    canvas.setPointerCapture(e.pointerId);
    const x = e.clientX, y = e.clientY;
    pointers.set(e.pointerId, { x, y });
    perPointerMeta.set(e.pointerId, { pointerId: e.pointerId });

    state.trails.set(e.pointerId, [{ x, y, t: performance.now() }]);

    callEffect("onDown", x, y, e.pointerId, 0, 0, 0);
    e.preventDefault();
  }, { passive: false });

  canvas.addEventListener("pointermove", (e) => {
    const pnt = pointers.get(e.pointerId);
    if (!pnt) return;

    const x = e.clientX, y = e.clientY;
    const vx = x - pnt.x;
    const vy = y - pnt.y;
    const dist = Math.hypot(vx, vy);
    const speed = dist;

    pnt.x = x; pnt.y = y;

    // trail points
    const tr = state.trails.get(e.pointerId);
    if (tr) {
      const last = tr[tr.length - 1];
      const dx = x - last.x, dy = y - last.y;
      const d = Math.hypot(dx, dy);
      const steps = Math.floor(d / 10);
      const now = performance.now();
      for (let i=1;i<=steps;i++) {
        const tt = i/(steps+1);
        tr.push({ x: last.x + dx*tt, y: last.y + dy*tt, t: now });
      }
      tr.push({ x, y, t: now });
      while (tr.length > 42) tr.shift();
    }

    callEffect("onMove", x, y, e.pointerId, speed, dist, dtGlobal);
    e.preventDefault();
  }, { passive: false });

  function endPointer(e) {
    if (!pointers.has(e.pointerId)) return;
    const pnt = pointers.get(e.pointerId);
    pointers.delete(e.pointerId);

    callEffect("onUp", pnt?.x ?? 0, pnt?.y ?? 0, e.pointerId, 0, 0, dtGlobal);

    setTimeout(() => {
      state.trails.delete(e.pointerId);
      perPointerMeta.delete(e.pointerId);
    }, 900);
  }
  canvas.addEventListener("pointerup", endPointer, { passive: true });
  canvas.addEventListener("pointercancel", endPointer, { passive: true });

  function callEffect(method, x, y, pointerId, speed, dist, dt) {
    const effect = effects.find(e => e.id === activeEffectId);
    const meta = perPointerMeta.get(pointerId) || { pointerId };
    meta.speed = speed;
    meta.dist = dist;
    meta.dt = dt;
    perPointerMeta.set(pointerId, meta);

    if (effect && typeof effect[method] === "function") effect[method](x, y, meta);
  }

  // ---------------- Visual systems ----------------
  function burstSparkles(x,y,count) {
    for (let i=0;i<count;i++) {
      const a = rand(0, Math.PI*2);
      const s = rand(0.6, 4.2);
      state.particles.push({
        kind:"sparkle",
        x,y, vx:Math.cos(a)*s, vy:Math.sin(a)*s,
        r:rand(1.2, 3.2),
        life:rand(0.25, 0.9),
        hue:rand(40, 70),
        tw:rand(0, Math.PI*2),
      });
    }
  }

  function burstStars(x,y,count,scale=1) {
    for (let i=0;i<count;i++) {
      const a = rand(0, Math.PI*2);
      const s = rand(0.8, 4.6) * scale;
      state.particles.push({
        kind:"tinyStar",
        x,y, vx:Math.cos(a)*s, vy:Math.sin(a)*s,
        size:rand(3, 8) * scale,
        rot:rand(0, Math.PI*2),
        vr:rand(-3, 3),
        life:rand(0.35, 1.1),
        hue:rand(40, 80),
      });
    }
  }

  function dropBlob(x,y,meta,strength=1) {
    const base = effectParams[activeEffectId]?.size ?? 24;
    state.blobs.push({
      x,y,
      r:rand(base*0.55, base*1.15) * strength,
      vx:rand(-0.9, 0.9) * strength,
      vy:rand(-0.9, 0.9) * strength,
      life:rand(0.7, 1.5),
      hue:rand(260, 320),
    });
    if ((meta?.speed ?? 0) > 12) burstStars(x,y, 2, 0.7);
  }

  function drawBigStar(x,y,points,rOuter,rInner,rot,fillStyle,alpha=1) {
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(rot);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = fillStyle;
    ctx.beginPath();
    for (let i=0;i<points*2;i++) {
      const r = (i%2===0) ? rOuter : rInner;
      const ang = (i/(points*2)) * Math.PI*2;
      ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
    }
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function spawnBurstStar(x,y,scale=1) {
    const effect = effects.find(e => e.id === activeEffectId);
    const points = Math.round(p("points"));
    const radius = p("radius") * scale;
    const wobble = p("wobble");
    state.particles.push({
      kind:"bigStar",
      x,y,
      points,
      radius,
      inner: radius * rand(0.35, 0.55),
      wobble,
      rot:rand(0, Math.PI*2),
      vr:rand(-1.5, 1.5),
      life:rand(0.45, 1.3),
      hue:rand(35, 70),
    });
  }

  function fireworkPop(x,y,scale=1) {
    const count = Math.round(p("count"));
    const spread = p("spread");
    const popSize = p("pop") * scale;
    for (let i=0;i<count;i++) {
      const a = rand(0, Math.PI*2);
      const sp = rand(0.8, 6.0) * spread;
      state.particles.push({
        kind:"fw",
        x,y,
        vx:Math.cos(a)*sp,
        vy:Math.sin(a)*sp,
        r:rand(1.2, 3.0) * (popSize/48),
        life:rand(0.35, 1.0),
        hue:rand(180, 330),
        glow:p("glow"),
      });
    }
    burstStars(x,y, 10, 1.0);
  }

function spawnBubble(x,y,scale=1) {
  const sz = p("bubbleSize") * scale;
  state.bubbles.push({
    x,y,
    r:rand(sz*0.7, sz*1.1),
    vy:rand(-1.0, -2.2) * p("rise"),
    vx:rand(-0.4, 0.4),
    life:rand(1.2, 2.6),
    phase:rand(0, Math.PI*2),
  });

  // NEW: bubble creation sound
  playBubbleBlip( lerp(0.35, 0.9, clamp(scale, 0.6, 1.4) - 0.6) );
}

  function drawBubbles() {
    ctx.save();
    for (const b of state.bubbles) {
      const a = clamp(b.life/0.6, 0, 1) * 0.7;
      ctx.globalAlpha = a;
      ctx.strokeStyle = "rgba(200,240,255,0.55)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.stroke();

      ctx.globalAlpha = a * 0.5;
      ctx.fillStyle = "rgba(255,255,255,0.35)";
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.25, b.y - b.r*0.25, b.r*0.25, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    ctx.restore();
  }

  function ensureRibbon(pointerId, x, y) {
    if (!state.ribbons.has(pointerId)) {
      state.ribbons.set(pointerId, {
        x,y, vx:0, vy:0,
        targetX:x, targetY:y,
        points:[{x,y,a:1}],
        hue:rand(0,360),
      });
    }
    const r = state.ribbons.get(pointerId);
    r.targetX = x;
    r.targetY = y;
  }

  function drawRibbons() {
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (const [id, r] of state.ribbons.entries()) {
      const spring = p("spring");
      const smooth = p("smooth");
      const fade = p("fade");

      if (r.targetX != null) {
        const ax = (r.targetX - r.x) * spring;
        const ay = (r.targetY - r.y) * spring;
        r.vx = (r.vx + ax) * (1 - smooth);
        r.vy = (r.vy + ay) * (1 - smooth);
        r.x += r.vx * 60 * dtGlobal;
        r.y += r.vy * 60 * dtGlobal;
        r.points.push({ x:r.x, y:r.y, a:1 });
        while (r.points.length > 60) r.points.shift();
      }

      for (const pt of r.points) pt.a -= dtGlobal * fade * 0.8;
      while (r.points.length && r.points[0].a <= 0) r.points.shift();

      if (r.points.length < 2) {
        if (!pointers.has(id)) state.ribbons.delete(id);
        continue;
      }

      const w = p("width");
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      ctx.beginPath();
      ctx.moveTo(r.points[0].x, r.points[0].y);
      for (let i=1;i<r.points.length;i++) ctx.lineTo(r.points[i].x, r.points[i].y);

      ctx.lineWidth = w;
      ctx.strokeStyle = `hsla(${r.hue}, 95%, 70%, 0.22)`;
      ctx.stroke();

      ctx.lineWidth = Math.max(2, w*0.55);
      ctx.strokeStyle = `hsla(${(r.hue+60)%360}, 95%, 75%, 0.28)`;
      ctx.stroke();

      r.hue = (r.hue + dtGlobal * 90) % 360;
    }
    ctx.restore();
  }

  function drawSoftBackground() {
    ctx.clearRect(0, 0, innerWidth, innerHeight);
    ctx.fillStyle = "#050510";
    ctx.fillRect(0, 0, innerWidth, innerHeight);

    const g = ctx.createRadialGradient(innerWidth*0.5, innerHeight*0.35, 30,
                                       innerWidth*0.5, innerHeight*0.35, Math.max(innerWidth, innerHeight)*0.7);
    g.addColorStop(0, "rgba(180,120,255,0.10)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,innerWidth,innerHeight);
  }

  function drawVignette() {
    const grad = ctx.createRadialGradient(innerWidth/2, innerHeight/2, Math.min(innerWidth, innerHeight)*0.2,
                                         innerWidth/2, innerHeight/2, Math.max(innerWidth, innerHeight)*0.75);
    grad.addColorStop(0, "rgba(0,0,0,0)");
    grad.addColorStop(1, "rgba(0,0,0,0.35)");
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,innerWidth,innerHeight);
  }

  function drawTrails(alpha=0.12) {
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (const pts of state.trails.values()) {
      if (!pts || pts.length < 2) continue;
      const age = performance.now() - pts[pts.length - 1].t;
      const a = clamp(1 - age / 900, 0, 1);
      if (a <= 0) continue;

      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.lineWidth = 18;
      ctx.strokeStyle = `rgba(120, 220, 255, ${alpha * a})`;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawGoo(blurPx=12) {
    gtx.clearRect(0,0,innerWidth,innerHeight);
    gtx.save();
    gtx.filter = `blur(${Math.max(0, blurPx)}px)`;
    gtx.globalCompositeOperation = "lighter";

    for (const b of state.blobs) {
      const a = clamp(b.life, 0, 1) * 0.9;
      gtx.fillStyle = `hsla(${b.hue}, 95%, 65%, ${a})`;
      gtx.beginPath();
      gtx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      gtx.fill();
    }
    gtx.restore();

    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.drawImage(gooCanvas, 0, 0, innerWidth, innerHeight);
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "white";
    for (const b of state.blobs) {
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.25, b.y - b.r*0.25, b.r*0.35, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  // ---------------- Auto slider modulation ----------------
  // Drifts values slowly, and ‚Äúreacts‚Äù slightly to activity (particle count).
  const modPhase = new Map(); // key -> phase
  function modulateSliders(dt) {
    if (!autoSliders) return;

    const effect = effects.find(e => e.id === activeEffectId);
    const params = effectParams[activeEffectId];
    const activity = clamp((state.particles.length + state.blobs.length + state.bubbles.length) / 220, 0, 1);

    for (const s of effect.sliders) {
      const key = `${activeEffectId}:${s.key}`;
      const ph = (modPhase.get(key) ?? rand(0, Math.PI*2)) + dt * (0.35 + activity*0.9);
      modPhase.set(key, ph);

      const amp = (s.mod ?? 0.12) * (1 + activity*0.6) * (s.max - s.min);
      const center = params[s.key];
      const drift = Math.sin(ph) * amp * 0.10;

      // rare tiny nudges
      const jitter = (Math.random() < dt * 0.25) ? rand(-1,1) * amp * 0.02 : 0;

      params[s.key] = clamp(center + drift + jitter, s.min, s.max);
    }
  }

  // Keep slider UI in sync while pane open
  function syncSliderUIIfOpen() {
    if (!paneOpen) return;
    buildSliders(); // simple + okay for small slider count
  }

  // ---------------- Auto-cycle effects ----------------
  let cycleTimer = 0;
  const CYCLE_SECONDS = 10; // change this if you want longer/shorter

  function maybeCycle(dt) {
    if (!autoCycle) return;
    cycleTimer += dt;
    if (cycleTimer >= CYCLE_SECONDS) {
      cycleTimer = 0;
      const idx = effects.findIndex(e => e.id === activeEffectId);
      const next = effects[(idx + 1) % effects.length].id;
      setEffect(next);
    }
  }

  // ---------------- Simulation update ----------------
  function update(dt) {
    // blobs
    for (let i=state.blobs.length-1;i>=0;i--) {
      const b = state.blobs[i];
      b.life -= dt;
      b.x += b.vx * 60 * dt;
      b.y += b.vy * 60 * dt;
      b.vx *= (1 - 1.8 * dt);
      b.vy *= (1 - 1.8 * dt);

      // floatiness param (negative floats upward)
      const float = (effectParams[activeEffectId]?.float ?? -0.25);
      b.vy += float * dt;

      b.r *= (0.996 + 0.002 * clamp(b.life/0.35,0,1));
      if (b.life <= 0 || b.r < 2) state.blobs.splice(i,1);
    }

    // bubbles
    for (let i=state.bubbles.length-1;i>=0;i--) {
      const b = state.bubbles[i];
      b.life -= dt;
      b.phase += dt * (0.8 + (p("wiggle") || 0) * 3.0);
      b.x += (b.vx + Math.sin(b.phase) * 0.8 * (p("wiggle") || 0)) * 60 * dt;
      b.y += b.vy * 60 * dt;

      if (b.y + b.r < -10 || b.life <= 0) {
        if (activeEffectId === "bubbles" && (p("popSpark") || 0) > 0.01) burstSparkles(b.x, b.y, Math.floor(16 * p("popSpark")));
        burstStars(b.x, b.y, 8, 0.8);
        playPop(0.4);
        state.bubbles.splice(i,1);
      }
    }

    // particles
    for (let i=state.particles.length-1;i>=0;i--) {
      const pt = state.particles[i];
      pt.life -= dt;

      if (pt.kind === "sparkle") {
        pt.x += pt.vx * 60 * dt;
        pt.y += pt.vy * 60 * dt;
        pt.vx *= (1 - 2.2 * dt);
        pt.vy *= (1 - 2.2 * dt);
        pt.vy += 0.8 * dt;
        pt.tw += 10 * dt;
      } else if (pt.kind === "tinyStar") {
        pt.x += pt.vx * 60 * dt;
        pt.y += pt.vy * 60 * dt;
        pt.vx *= (1 - 1.8 * dt);
        pt.vy *= (1 - 1.8 * dt);
        pt.vy += 0.7 * dt;
        pt.rot += pt.vr * dt;
      } else if (pt.kind === "bigStar") {
        pt.rot += pt.vr * dt;
      } else if (pt.kind === "fw") {
        const drag = (p("drag") ?? 0.10);
        pt.x += pt.vx * 60 * dt;
        pt.y += pt.vy * 60 * dt;
        pt.vx *= (1 - drag);
        pt.vy *= (1 - drag);
        pt.vy += 0.9 * dt;
      }

      if (pt.life <= 0) state.particles.splice(i,1);
    }

    // auto modulation + cycling
    modulateSliders(dt);
    maybeCycle(dt);

    // update slider UI only if pane open
    syncSliderUIIfOpen();

    // hint fade
    if (hintTimer > 0) {
      hintTimer -= dt;
      if (hintTimer <= 0) hint.classList.add("hidden");
    }
  }

  function draw() {
    drawSoftBackground();

    // effect overlay
    const effect = effects.find(e => e.id === activeEffectId);
    effect?.drawOverlay?.();

    // Draw particles
    ctx.save();
    ctx.globalCompositeOperation = "lighter";

    for (const pt of state.particles) {
      if (pt.kind === "sparkle") {
        const a = clamp(pt.life / 0.35, 0, 1);
        const tw = 0.6 + 0.4 * Math.sin(pt.tw);
        ctx.fillStyle = `hsla(${pt.hue}, 95%, 70%, ${a * tw})`;
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, pt.r * (0.7 + tw), 0, Math.PI*2);
        ctx.fill();
      } else if (pt.kind === "tinyStar") {
        const a = clamp(pt.life / 0.35, 0, 1);
        drawBigStar(pt.x, pt.y, 5, pt.size, pt.size*0.5, pt.rot, `hsla(${pt.hue},95%,70%,${a})`, 1);
      } else if (pt.kind === "bigStar") {
        const a = clamp(pt.life / 0.45, 0, 1);
        const wob = pt.wobble ?? 0.3;
        const rr = pt.radius * (1 + Math.sin(performance.now()*0.003 + pt.rot) * 0.08 * wob);
        const ri = pt.inner  * (1 + Math.cos(performance.now()*0.003 + pt.rot) * 0.10 * wob);
        drawBigStar(pt.x, pt.y, pt.points, rr, ri, pt.rot, `hsla(${pt.hue},95%,68%,${a})`, 1);
        ctx.globalAlpha = a * 0.25;
        ctx.strokeStyle = `hsla(${pt.hue},95%,80%,1)`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, rr*0.75, 0, Math.PI*2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      } else if (pt.kind === "fw") {
        const a = clamp(pt.life / 0.35, 0, 1) * (pt.glow ?? 0.8);
        ctx.fillStyle = `hsla(${pt.hue}, 95%, 70%, ${a})`;
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, pt.r * (0.7 + a), 0, Math.PI*2);
        ctx.fill();
      }
    }

    ctx.restore();

    // bubbles drawn by overlay in bubble effect
    drawVignette();
  }

  // ---------------- Animation loop ----------------
  let last = performance.now();
  let dtGlobal = 0.016;

  function frame(now) {
    dtGlobal = Math.min(0.033, (now - last)/1000);
    last = now;

    // provide dt to pointer meta
    for (const meta of perPointerMeta.values()) meta.dt = dtGlobal;

    update(dtGlobal);
    draw();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // ---------------- Initial UI state ----------------
  function populateEffectSelect() {
    effectSelect.innerHTML = "";
    for (const e of effects) {
      const opt = document.createElement("option");
      opt.value = e.id;
      opt.textContent = e.name;
      effectSelect.appendChild(opt);
    }
  }
  populateEffectSelect();
  setEffect(activeEffectId);
  buildSliders();
  setPaneOpen(false);

  // If user taps empty space, show hint briefly (optional)
  canvas.addEventListener("pointerdown", () => {
    hint.classList.add("hidden");
  }, { passive: true });
})();
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Bubble Pop! (v7)</title>
  <style>
    html, body {
      margin: 0; height: 100%;
      background: linear-gradient(180deg, #0a0520 0%, #1a1540 100%);
      overflow: hidden;
      touch-action: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    canvas { display:block; width:100vw; height:100vh; }

    .score {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      
      font: 900 48px/1 system-ui;
      color: rgba(255,255,255,0.95);
      text-shadow: 0 4px 12px rgba(0,0,0,0.5),
                   0 0 20px rgba(140, 255, 210, 0.4);
      user-select: none;
      -webkit-user-select: none;
      pointer-events: none;
    }

    .combo {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      
      font: 700 24px/1 system-ui;
      color: rgba(255, 200, 100, 0.95);
      text-shadow: 0 2px 8px rgba(0,0,0,0.5);
      user-select: none;
      -webkit-user-select: none;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .combo.active { opacity: 1; }

    .info {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      
      font: 600 16px/1.3 system-ui;
      color: rgba(255,255,255,0.7);
      text-shadow: 0 2px 6px rgba(0,0,0,0.5);
      text-align: center;
      user-select: none;
      -webkit-user-select: none;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="score" class="score">0</div>
  <div id="combo" class="combo"></div>
  <div class="info">Pop the bubbles! âœ¨<br>Different bubbles = different explosions</div>
  <canvas id="c"></canvas>

<script>
(() => {
  // ---------------- Canvas setup ----------------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: true });

  function resize() {
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener("resize", resize, { passive: true });
  resize();

  // ---------------- Helpers ----------------
  const rand = (a,b)=>a+Math.random()*(b-a);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;

  // ---------------- Game State ----------------
  let score = 0;
  let combo = 0;
  let comboTimer = 0;
  let bubblesPopped = 0;
  let bubblesEscaped = 0;
  let performanceCheckTimer = 0;
  let difficultyLevel = 1.0; // Multiplier for spawn rate
  
  const scoreEl = document.getElementById("score");
  const comboEl = document.getElementById("combo");

  const state = {
    bubbles: [],
    particles: [],
    dragTrails: [], // Trails from dragging
  };

  function updateScore(points) {
    const oldScore = score;
    score += points;
    scoreEl.textContent = score;
    
    bubblesPopped++;
    
    combo++;
    comboTimer = 2.0;
    if (combo > 1) {
      comboEl.textContent = `${combo}x COMBO!`;
      comboEl.classList.add("active");
    }
    
    // Celebratory confetti on milestones
    checkMilestones(oldScore, score, combo);
  }

  // Confetti celebration effects
  function spawnConfetti(x, y, amount, spreadX = 300, spreadY = 400) {
    for (let i = 0; i < amount; i++) {
      const angle = rand(-Math.PI/3, -Math.PI*2/3); // Upward spray
      const speed = rand(8, 18);
      const shapeType = Math.floor(Math.random() * 4);
      let kind;
      if (shapeType === 0) kind = "confetti";
      else if (shapeType === 1) kind = "star";
      else if (shapeType === 2) kind = "circle";
      else kind = "diamond";
      
      state.particles.push({
        kind,
        x: x + rand(-spreadX/2, spreadX/2),
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        w: kind === "confetti" ? rand(3, 6) : undefined,
        h: kind === "confetti" ? rand(8, 14) : undefined,
        r: kind === "circle" ? rand(3, 7) : undefined,
        size: (kind === "star" || kind === "diamond") ? rand(4, 9) : undefined,
        rot: rand(0, Math.PI*2),
        vr: rand(-20, 20),
        twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
        life: rand(1.2, 2.0),
        hue: rand(0, 360),
        gravity: 1.4,
        fadeType: Math.floor(Math.random() * 3),
      });
    }
  }

  function checkMilestones(oldScore, newScore, currentCombo) {
    const milestones = [100, 250, 500, 1000, 2000, 5000, 10000];
    
    // Score milestone confetti
    for (const milestone of milestones) {
      if (oldScore < milestone && newScore >= milestone) {
        // Big celebration at screen center
        spawnConfetti(innerWidth / 2, innerHeight * 0.3, 80, 400, 300);
        playCheer(1.0);
        break;
      }
    }
    
    // Combo milestone confetti
    if (currentCombo === 5 || currentCombo === 10 || currentCombo === 15 || 
        currentCombo === 20 || currentCombo === 30 || currentCombo === 50) {
      spawnConfetti(innerWidth / 2, innerHeight * 0.4, 60, 350, 250);
      playCheer(0.8);
    }
    
    // Smaller confetti for every 5 combo after 10
    else if (currentCombo > 10 && currentCombo % 5 === 0) {
      spawnConfetti(innerWidth / 2, innerHeight * 0.5, 30, 250, 200);
      playCheer(0.6);
    }
  }

  function playCheer(intensity = 1.0) {
    if (!audioPrimed) return;
    // Ascending chime celebration
    const baseFreq = 520;
    playTone(baseFreq * intensity, 0.08, "sine", 0.12);
    setTimeout(() => playTone(baseFreq * 1.25 * intensity, 0.08, "sine", 0.14), 60);
    setTimeout(() => playTone(baseFreq * 1.5 * intensity, 0.10, "sine", 0.16), 120);
  }

  function bubbleEscaped() {
    bubblesEscaped++;
    combo = 0;
    comboEl.classList.remove("active");
  }

  // Dynamic difficulty adjustment
  function adjustDifficulty(dt) {
    performanceCheckTimer += dt;
    
    // Check performance every 5 seconds
    if (performanceCheckTimer >= 5.0) {
      performanceCheckTimer = 0;
      
      const total = bubblesPopped + bubblesEscaped;
      if (total > 0) {
        const successRate = bubblesPopped / total;
        
        // If popping 90%+ of bubbles, increase difficulty
        if (successRate >= 0.9 && difficultyLevel < 3.0) {
          difficultyLevel += 0.2;
          // Celebrate perfect or near-perfect performance!
          if (successRate >= 0.95) {
            spawnConfettiCannons(100);
            playCheer(1.2);
          }
        }
        // If missing 50%+ of bubbles, decrease difficulty
        else if (successRate < 0.5 && difficultyLevel > 0.5) {
          difficultyLevel -= 0.15;
        }
        // Moderate success, slight increase
        else if (successRate >= 0.75 && difficultyLevel < 2.5) {
          difficultyLevel += 0.1;
        }
        
        // Clamp difficulty
        difficultyLevel = clamp(difficultyLevel, 0.5, 3.0);
      }
      
      // Reset counters
      bubblesPopped = 0;
      bubblesEscaped = 0;
    }
  }

  // Confetti cannons from screen edges
  function spawnConfettiCannons(amount) {
    // Left cannon
    spawnConfetti(50, innerHeight * 0.6, amount / 2, 100, 400);
    // Right cannon
    setTimeout(() => {
      spawnConfetti(innerWidth - 50, innerHeight * 0.6, amount / 2, 100, 400);
    }, 150);
  }

  // ---------------- Sound (Web Audio) ----------------
  let audioCtx = null;
  let audioPrimed = false;

  function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
    audioPrimed = true;
  }

  function playTone(freq, dur=0.08, type="sine", vol=0.05) {
    if (!audioPrimed) return;
    const t0 = audioCtx.currentTime;

    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    o.type = type;
    o.frequency.setValueAtTime(freq, t0);

    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

    o.connect(g);
    g.connect(audioCtx.destination);

    o.start(t0);
    o.stop(t0 + dur + 0.02);
  }

  // Different pop sounds
  function playPopSound(type) {
    switch(type) {
      case 0: // Soft pop
        playTone(rand(300, 500), 0.08, "sine", 0.15);
        break;
      case 1: // Sharp pop
        playTone(rand(600, 900), 0.05, "triangle", 0.18);
        setTimeout(() => playTone(rand(400, 600), 0.04, "sine", 0.12), 20);
        break;
      case 2: // Deep boom
        playTone(rand(120, 200), 0.12, "sawtooth", 0.20);
        setTimeout(() => playTone(rand(80, 120), 0.08, "triangle", 0.15), 30);
        break;
      case 3: // Sparkly
        playTone(rand(800, 1200), 0.04, "sine", 0.14);
        setTimeout(() => playTone(rand(1000, 1600), 0.03, "sine", 0.10), 15);
        setTimeout(() => playTone(rand(1200, 1800), 0.025, "sine", 0.08), 30);
        break;
      case 4: // Wobble
        playTone(rand(250, 350), 0.10, "sine", 0.16);
        setTimeout(() => playTone(rand(180, 280), 0.08, "sine", 0.14), 40);
        break;
      case 5: // Whistle
        playTone(rand(1500, 2200), 0.06, "sine", 0.12);
        break;
      case 6: // Crackle
        playTone(rand(400, 700), 0.03, "square", 0.14);
        setTimeout(() => playTone(rand(300, 600), 0.025, "sawtooth", 0.12), 20);
        break;
    }
  }

  // ---------------- Bubble Types ----------------
  const bubbleTypes = [
    { 
      name: "Standard", 
      color: [180, 220], // hue range
      size: [30, 50],
      speed: [0.8, 1.4],
      points: 10,
      explosionType: 0,
      weight: 40
    },
    { 
      name: "Fast", 
      color: [0, 40], // red-orange
      size: [20, 35],
      speed: [2.0, 3.0],
      points: 20,
      explosionType: 1,
      weight: 20
    },
    { 
      name: "Giant", 
      color: [280, 320], // purple-pink
      size: [60, 90],
      speed: [0.4, 0.7],
      points: 30,
      explosionType: 2,
      weight: 10
    },
    { 
      name: "Sparkler", 
      color: [40, 80], // yellow-gold
      size: [25, 40],
      speed: [1.0, 1.8],
      points: 25,
      explosionType: 3,
      weight: 15
    },
    { 
      name: "Wobbler", 
      color: [120, 180], // green-cyan
      size: [35, 55],
      speed: [0.6, 1.2],
      points: 15,
      explosionType: 4,
      weight: 20
    },
    { 
      name: "Tiny", 
      color: [260, 300], // purple-blue
      size: [15, 25],
      speed: [2.5, 4.0],
      points: 35,
      explosionType: 5,
      weight: 8
    },
    { 
      name: "Crackler", 
      color: [320, 360], // pink-red
      size: [40, 60],
      speed: [1.2, 2.0],
      points: 22,
      explosionType: 6,
      weight: 12
    },
  ];

  function getRandomBubbleType() {
    const totalWeight = bubbleTypes.reduce((sum, t) => sum + t.weight, 0);
    let r = Math.random() * totalWeight;
    for (const type of bubbleTypes) {
      r -= type.weight;
      if (r <= 0) return type;
    }
    return bubbleTypes[0];
  }

  // ---------------- Spawn Bubbles ----------------
  function spawnBubble() {
    const type = getRandomBubbleType();
    const hue = rand(type.color[0], type.color[1]);
    const r = rand(type.size[0], type.size[1]);
    const speed = rand(type.speed[0], type.speed[1]);
    
    state.bubbles.push({
      x: rand(r + 20, innerWidth - r - 20),
      y: innerHeight + r + 10,
      r,
      vy: -speed,
      vx: rand(-0.3, 0.3),
      life: 1.0,
      phase: rand(0, Math.PI*2),
      wiggleSpeed: rand(0.5, 2.0),
      wiggleAmp: rand(0.5, 2.0),
      hue,
      type,
    });
  }

  // ---------------- Explosion Types ----------------
  function explodeBubble(bubble) {
    const x = bubble.x;
    const y = bubble.y;
    const r = bubble.r;
    const type = bubble.type.explosionType;
    const hue = bubble.hue;

    playPopSound(type);

    switch(type) {
      case 0: // Standard burst - MORE PARTICLES, RAINBOW COLORS
        for (let i=0; i<50; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(2, 9);
          const layer = i % 3;
          // Mix circles and stars
          const kind = i % 4 === 0 ? "star" : "circle";
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: kind === "circle" ? rand(2, 6) : undefined,
            size: kind === "star" ? rand(3, 7) : undefined,
            rot: kind === "star" ? rand(0, Math.PI*2) : undefined,
            vr: kind === "star" ? rand(-10, 10) : undefined,
            twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
            life: rand(0.5, 1.2),
            hue: hue + rand(-60, 60),
            gravity: 0.8,
            fadeType: layer, // 0=linear, 1=slow-start, 2=fast-start
          });
        }
        // Add inner spray of different color with triangles
        for (let i=0; i<20; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(1, 4);
          const kind = i % 3 === 0 ? "triangle" : "circle";
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(3, 8),
            rot: kind === "triangle" ? rand(0, Math.PI*2) : undefined,
            vr: kind === "triangle" ? rand(-8, 8) : undefined,
            life: rand(0.6, 1.0),
            hue: (hue + 180) % 360, // complementary color
            gravity: 0.5,
            fadeType: 1,
          });
        }
        break;

      case 1: // Sharp shards - MORE SHARDS, COLORFUL, WITH STARS
        for (let i=0; i<60; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(4, 14);
          state.particles.push({
            kind: "shard",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            w: rand(2, 5),
            h: rand(8, 20),
            rot: a,
            vr: rand(-12, 12),
            life: rand(0.4, 0.9),
            hue: hue + rand(-90, 90),
            gravity: 0.6,
            fadeType: i % 2,
          });
        }
        // Add stars and diamonds
        for (let i=0; i<30; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(6, 12);
          const kind = i % 2 === 0 ? "star" : "diamond";
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            size: rand(4, 8),
            rot: rand(0, Math.PI*2),
            vr: rand(-15, 15),
            twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
            life: rand(0.3, 0.6),
            hue: rand(0, 360),
            gravity: 1.0,
            fadeType: 2,
          });
        }
        break;

      case 2: // Giant slow rings - MORE RINGS AND COLORS
        for (let i=0; i<5; i++) {
          setTimeout(() => {
            state.particles.push({
              kind: "ring",
              x, y,
              r: r * 0.3,
              growSpeed: rand(3, 6),
              life: rand(0.8, 1.4),
              hue: hue + i * 30,
              fadeType: i % 3,
            });
          }, i * 60);
        }
        // Lots of colorful debris with varied shapes
        for (let i=0; i<80; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(1, 5);
          const colorShift = (i / 80) * 360; // full spectrum
          const shapeType = Math.floor(i / 20); // 4 shape types
          let kind;
          if (shapeType === 0) kind = "circle";
          else if (shapeType === 1) kind = "star";
          else if (shapeType === 2) kind = "triangle";
          else kind = "diamond";
          
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: kind === "circle" ? rand(3, 10) : undefined,
            size: kind !== "circle" ? rand(4, 9) : undefined,
            rot: kind !== "circle" ? rand(0, Math.PI*2) : undefined,
            vr: kind !== "circle" ? rand(-10, 10) : undefined,
            twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
            life: rand(0.6, 1.4),
            hue: (hue + colorShift) % 360,
            gravity: 0.3,
            fadeType: Math.floor(i / 27),
          });
        }
        // Add some glowing orbs
        for (let i=0; i<15; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(2, 4);
          state.particles.push({
            kind: "glow",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(6, 12),
            life: rand(0.8, 1.6),
            hue: hue + rand(-60, 60),
            gravity: 0.2,
            fadeType: 1,
          });
        }
        break;

      case 3: // Sparkly stars - TONS OF SPARKLES
        for (let i=0; i<100; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(3, 15);
          const ring = Math.floor(i / 20); // 5 rings of different colors
          state.particles.push({
            kind: "star",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            size: rand(3, 10),
            rot: rand(0, Math.PI*2),
            vr: rand(-15, 15),
            life: rand(0.5, 1.2),
            hue: (hue + ring * 72) % 360, // golden angle distribution
            gravity: 0.7,
            twinkle: rand(0, Math.PI*2),
            fadeType: ring % 3,
          });
        }
        // Add tiny fast sparkles
        for (let i=0; i<50; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(8, 18);
          state.particles.push({
            kind: "circle",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(1, 2),
            life: rand(0.3, 0.6),
            hue: rand(0, 360),
            gravity: 1.2,
            fadeType: 2,
          });
        }
        break;

      case 4: // Wobbling blobs - MORE VARIED BLOBS
        for (let i=0; i<50; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(1.5, 7);
          state.particles.push({
            kind: "blob",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(4, 14),
            life: rand(0.7, 1.5),
            hue: hue + rand(-120, 120),
            gravity: 0.7,
            phase: rand(0, Math.PI*2),
            wobbleSpeed: rand(3, 10),
            fadeType: i % 3,
          });
        }
        // Add contrasting color particles with varied shapes
        for (let i=0; i<30; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(3, 8);
          const kind = i % 3 === 0 ? "star" : (i % 3 === 1 ? "diamond" : "circle");
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: kind === "circle" ? rand(2, 6) : undefined,
            size: kind !== "circle" ? rand(3, 7) : undefined,
            rot: kind !== "circle" ? rand(0, Math.PI*2) : undefined,
            vr: kind !== "circle" ? rand(-12, 12) : undefined,
            twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
            life: rand(0.5, 1.0),
            hue: (hue + 180) % 360,
            gravity: 0.9,
            fadeType: 1,
          });
        }
        break;

      case 5: // Tiny fast confetti - MASSIVE CONFETTI STORM
        for (let i=0; i<120; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(8, 20);
          state.particles.push({
            kind: "confetti",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            w: rand(2, 5),
            h: rand(6, 14),
            rot: rand(0, Math.PI*2),
            vr: rand(-25, 25),
            life: rand(0.4, 1.0),
            hue: rand(0, 360), // fully random colors
            gravity: 1.4,
            fadeType: i % 3,
          });
        }
        // Add rainbow circles and other shapes
        for (let i=0; i<40; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(10, 18);
          const kind = i % 4 === 0 ? "star" : (i % 4 === 1 ? "diamond" : (i % 4 === 2 ? "triangle" : "circle"));
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: kind === "circle" ? rand(1, 3) : undefined,
            size: kind !== "circle" ? rand(2, 5) : undefined,
            rot: kind !== "circle" ? rand(0, Math.PI*2) : undefined,
            vr: kind !== "circle" ? rand(-20, 20) : undefined,
            twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
            life: rand(0.3, 0.7),
            hue: (i / 40) * 360, // full spectrum
            gravity: 1.6,
            fadeType: 2,
          });
        }
        break;

      case 6: // Crackle with trails - MORE TRAILS, MORE COLORS
        for (let i=0; i<70; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(4, 12);
          state.particles.push({
            kind: "trail",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(2, 6),
            life: rand(0.6, 1.4),
            hue: hue + rand(-90, 90),
            gravity: 1.0,
            trail: [{x, y}],
            fadeType: i % 3,
          });
        }
        // Add explosive shards
        for (let i=0; i<40; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(6, 14);
          state.particles.push({
            kind: "shard",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            w: rand(3, 6),
            h: rand(10, 18),
            rot: a,
            vr: rand(-15, 15),
            life: rand(0.5, 1.0),
            hue: (hue + i * 9) % 360, // rainbow spiral
            gravity: 0.8,
            fadeType: 1,
          });
        }
        // Add glowing core particles
        for (let i=0; i<20; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(2, 6);
          state.particles.push({
            kind: "glow",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(4, 10),
            life: rand(0.7, 1.3),
            hue: hue + rand(-45, 45),
            gravity: 0.5,
            fadeType: 0,
          });
        }
        break;
    }
  }

  // ---------------- Input Handling ----------------
  let isDragging = false;
  let currentDragTrail = null;
  let lastDragCheck = { x: 0, y: 0 };

  function handlePointerDown(e) {
    if (!audioPrimed) {
      ensureAudio();
      playPopSound(0);
    }

    const x = e.clientX;
    const y = e.clientY;
    
    isDragging = true;
    lastDragCheck = { x, y };
    
    // Create new drag trail
    currentDragTrail = {
      points: [{ x, y, time: performance.now() }],
      hue: rand(0, 360),
      width: 8,
    };
    state.dragTrails.push(currentDragTrail);

    // Check for bubble hit
    checkBubbleHit(x, y);
  }

  function handlePointerMove(e) {
    if (!isDragging) return;
    
    const x = e.clientX;
    const y = e.clientY;
    
    // Add point to trail
    if (currentDragTrail) {
      const lastPoint = currentDragTrail.points[currentDragTrail.points.length - 1];
      const dist = Math.hypot(x - lastPoint.x, y - lastPoint.y);
      
      // Add point if moved enough
      if (dist > 5) {
        currentDragTrail.points.push({ x, y, time: performance.now() });
        
        // Spawn sparkles along the trail
        if (Math.random() < 0.3) {
          state.particles.push({
            kind: "star",
            x: x + rand(-5, 5),
            y: y + rand(-5, 5),
            vx: rand(-1, 1),
            vy: rand(-1, 1),
            size: rand(2, 5),
            rot: rand(0, Math.PI*2),
            vr: rand(-10, 10),
            twinkle: rand(0, Math.PI*2),
            life: rand(0.3, 0.6),
            hue: currentDragTrail.hue + rand(-30, 30),
            gravity: 0.3,
            fadeType: 2,
          });
        }
      }
    }
    
    // Check for bubbles along the drag path
    const dx = x - lastDragCheck.x;
    const dy = y - lastDragCheck.y;
    const dist = Math.hypot(dx, dy);
    
    // Check multiple points along the drag path
    const steps = Math.max(1, Math.floor(dist / 10));
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const checkX = lastDragCheck.x + dx * t;
      const checkY = lastDragCheck.y + dy * t;
      checkBubbleHit(checkX, checkY);
    }
    
    lastDragCheck = { x, y };
  }

  function handlePointerUp(e) {
    isDragging = false;
    currentDragTrail = null;
  }

  function checkBubbleHit(x, y) {
    // Check for bubble hit
    for (let i = state.bubbles.length - 1; i >= 0; i--) {
      const b = state.bubbles[i];
      const dx = x - b.x;
      const dy = y - b.y;
      const dist = Math.hypot(dx, dy);

      if (dist < b.r) {
        explodeBubble(b);
        const pointsEarned = b.type.points * Math.max(1, combo);
        updateScore(pointsEarned);
        
        // Extra confetti for high-value pops
        if (b.type.points >= 30) {
          // Tiny or Giant bubbles get extra celebration
          spawnMiniConfetti(b.x, b.y, 20);
        }
        
        // Big confetti for huge combo multipliers
        if (combo >= 15) {
          spawnMiniConfetti(b.x, b.y, 15);
        }
        
        state.bubbles.splice(i, 1);
      }
    }
  }

  canvas.addEventListener("pointerdown", handlePointerDown, { passive: true });
  canvas.addEventListener("pointermove", handlePointerMove, { passive: true });
  canvas.addEventListener("pointerup", handlePointerUp, { passive: true });
  canvas.addEventListener("pointercancel", handlePointerUp, { passive: true });

  // Mini confetti burst at pop location
  function spawnMiniConfetti(x, y, amount) {
    for (let i = 0; i < amount; i++) {
      const angle = rand(0, Math.PI * 2);
      const speed = rand(4, 10);
      const shapeType = Math.floor(Math.random() * 3);
      let kind = shapeType === 0 ? "star" : (shapeType === 1 ? "diamond" : "circle");
      
      state.particles.push({
        kind,
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        r: kind === "circle" ? rand(2, 4) : undefined,
        size: kind !== "circle" ? rand(3, 6) : undefined,
        rot: rand(0, Math.PI*2),
        vr: rand(-15, 15),
        twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
        life: rand(0.4, 0.8),
        hue: rand(0, 360),
        gravity: 1.0,
        fadeType: 2,
      });
    }
  }

  canvas.addEventListener("pointerdown", handlePointerDown, { passive: true });

  // ---------------- Update ----------------
  function update(dt) {
    // Update bubbles
    for (let i = state.bubbles.length - 1; i >= 0; i--) {
      const b = state.bubbles[i];
      b.phase += dt * b.wiggleSpeed;
      b.x += (b.vx + Math.sin(b.phase) * b.wiggleAmp) * 60 * dt;
      b.y += b.vy * 60 * dt;

      // Remove if off screen
      if (b.y + b.r < -10) {
        state.bubbles.splice(i, 1);
        bubbleEscaped();
      }
    }

    // Update drag trails (fade out old points)
    const now = performance.now();
    for (let i = state.dragTrails.length - 1; i >= 0; i--) {
      const trail = state.dragTrails[i];
      
      // Remove old points (older than 1 second)
      trail.points = trail.points.filter(p => now - p.time < 1000);
      
      // Remove trail if no points left
      if (trail.points.length === 0) {
        state.dragTrails.splice(i, 1);
      }
    }

    // Update particles
    for (let i = state.particles.length - 1; i >= 0; i--) {
      const p = state.particles[i];
      p.life -= dt;

      if (p.kind === "ring") {
        p.r += p.growSpeed * 60 * dt;
      } else {
        p.x += p.vx * 60 * dt;
        p.y += p.vy * 60 * dt;
        
        if (p.gravity !== undefined) {
          p.vy += p.gravity * dt;
        }

        if (p.vr !== undefined) {
          p.rot += p.vr * dt;
        }

        if (p.kind === "blob") {
          p.phase += dt * p.wobbleSpeed;
        }

        if (p.kind === "star") {
          p.twinkle += dt * 10;
        }

        if (p.kind === "trail") {
          p.trail.push({x: p.x, y: p.y});
          if (p.trail.length > 8) p.trail.shift();
        }

        // Drag
        p.vx *= (1 - 0.8 * dt);
        p.vy *= (1 - 0.8 * dt);
      }

      if (p.life <= 0) {
        state.particles.splice(i, 1);
      }
    }

    // Combo timer
    if (comboTimer > 0) {
      comboTimer -= dt;
      if (comboTimer <= 0) {
        combo = 0;
        comboEl.classList.remove("active");
      }
    }
  }

  // ---------------- Draw ----------------
  function draw() {
    // Background
    ctx.fillStyle = "rgba(10, 5, 32, 0.15)";
    ctx.fillRect(0, 0, innerWidth, innerHeight);

    // Draw drag trails first (behind everything)
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    const now = performance.now();
    
    for (const trail of state.dragTrails) {
      if (trail.points.length < 2) continue;
      
      // Draw gradient trail
      for (let i = 1; i < trail.points.length; i++) {
        const p1 = trail.points[i - 1];
        const p2 = trail.points[i];
        
        // Calculate age-based alpha for each segment
        const age1 = (now - p1.time) / 1000; // 0 to 1 second
        const age2 = (now - p2.time) / 1000;
        const alpha1 = 1 - age1;
        const alpha2 = 1 - age2;
        
        // Create gradient along segment
        const gradient = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
        gradient.addColorStop(0, `hsla(${trail.hue}, 90%, 70%, ${alpha1 * 0.6})`);
        gradient.addColorStop(1, `hsla(${trail.hue}, 90%, 70%, ${alpha2 * 0.6})`);
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = trail.width * Math.max(alpha1, alpha2);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }
      
      // Draw glowing core on recent trail points
      for (let i = 0; i < trail.points.length; i++) {
        const p = trail.points[i];
        const age = (now - p.time) / 1000;
        const alpha = (1 - age) * 0.4;
        
        if (alpha > 0.1) {
          ctx.globalAlpha = alpha;
          const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, trail.width * 1.5);
          glow.addColorStop(0, `hsla(${trail.hue + 30}, 100%, 85%, 1)`);
          glow.addColorStop(1, `hsla(${trail.hue}, 90%, 70%, 0)`);
          ctx.fillStyle = glow;
          ctx.beginPath();
          ctx.arc(p.x, p.y, trail.width * 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
    ctx.restore();

    // Draw particles
    ctx.save();
    ctx.globalCompositeOperation = "lighter";

    for (const p of state.particles) {
      // Different fade types
      let a;
      const fadeType = p.fadeType || 0;
      if (fadeType === 0) {
        // Linear fade
        a = clamp(p.life / 0.4, 0, 1);
      } else if (fadeType === 1) {
        // Slow start fade (stays bright longer)
        const t = clamp(p.life / 0.5, 0, 1);
        a = t * t;
      } else {
        // Fast start fade (quick fade out)
        const t = clamp(p.life / 0.3, 0, 1);
        a = Math.sqrt(t);
      }

      if (p.kind === "circle") {
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 85%, 65%)`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.fill();
      } 
      else if (p.kind === "glow") {
        // Glowing orb with radial gradient
        ctx.globalAlpha = a * 0.8;
        const grd = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r);
        grd.addColorStop(0, `hsla(${p.hue}, 95%, 85%, 1)`);
        grd.addColorStop(0.5, `hsla(${p.hue}, 90%, 70%, 0.6)`);
        grd.addColorStop(1, `hsla(${p.hue}, 85%, 60%, 0)`);
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r * 1.5, 0, Math.PI*2);
        ctx.fill();
      }
      else if (p.kind === "ring") {
        ctx.globalAlpha = a * 0.6;
        ctx.strokeStyle = `hsl(${p.hue}, 85%, 70%)`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.stroke();
      }
      else if (p.kind === "shard") {
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 90%, 70%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
        ctx.restore();
      }
      else if (p.kind === "star") {
        const tw = p.twinkle !== undefined ? (0.7 + 0.3 * Math.sin(p.twinkle)) : 1;
        ctx.globalAlpha = a * tw;
        ctx.fillStyle = `hsl(${p.hue}, 95%, 75%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot || 0);
        ctx.beginPath();
        for (let i=0; i<5; i++) {
          const ang = (i/5) * Math.PI * 2;
          const r = i % 2 === 0 ? p.size : p.size * 0.4;
          ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      else if (p.kind === "triangle") {
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 90%, 70%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot || 0);
        ctx.beginPath();
        const s = p.r || p.size;
        ctx.moveTo(0, -s);
        ctx.lineTo(s * 0.866, s * 0.5);
        ctx.lineTo(-s * 0.866, s * 0.5);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      else if (p.kind === "diamond") {
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 92%, 72%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot || 0);
        ctx.beginPath();
        const s = p.size || p.r;
        ctx.moveTo(0, -s);
        ctx.lineTo(s * 0.6, 0);
        ctx.lineTo(0, s);
        ctx.lineTo(-s * 0.6, 0);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      else if (p.kind === "blob") {
        const wobble = Math.sin(p.phase) * 0.2 + 1;
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 85%, 65%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.scale(wobble, 1/wobble);
        ctx.beginPath();
        ctx.arc(0, 0, p.r, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      else if (p.kind === "confetti") {
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 90%, 65%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
        ctx.restore();
      }
      else if (p.kind === "trail") {
        ctx.globalAlpha = a;
        ctx.strokeStyle = `hsl(${p.hue}, 90%, 70%)`;
        ctx.lineWidth = p.r;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.beginPath();
        for (let i=0; i<p.trail.length; i++) {
          const pt = p.trail[i];
          if (i === 0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
        }
        ctx.stroke();
        
        // Draw head
        ctx.fillStyle = `hsl(${p.hue}, 95%, 75%)`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r * 1.2, 0, Math.PI*2);
        ctx.fill();
      }
    }
    ctx.restore();

    // Draw bubbles
    ctx.save();
    for (const b of state.bubbles) {
      const hue = b.hue;
      
      // Outer glow
      ctx.globalAlpha = 0.3;
      const glow = ctx.createRadialGradient(b.x, b.y, b.r * 0.5, b.x, b.y, b.r * 1.3);
      glow.addColorStop(0, `hsla(${hue}, 85%, 70%, 0.4)`);
      glow.addColorStop(1, `hsla(${hue}, 85%, 70%, 0)`);
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r * 1.3, 0, Math.PI*2);
      ctx.fill();

      // Main bubble
      ctx.globalAlpha = 0.6;
      ctx.strokeStyle = `hsla(${hue}, 80%, 65%, 0.9)`;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.stroke();

      // Highlight
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = `hsla(${hue}, 90%, 85%, 0.6)`;
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.3, b.y - b.r*0.3, b.r*0.3, 0, Math.PI*2);
      ctx.fill();

      // Small highlight
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = `hsla(${hue}, 95%, 95%, 0.8)`;
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.4, b.y - b.r*0.4, b.r*0.15, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  // ---------------- Bubble Spawner ----------------
  let spawnTimer = 0;
  const BASE_SPAWN_INTERVAL = 0.8;
  const MAX_BUBBLES = 15; // Maximum comfortable bubble count
  const CROWDED_THRESHOLD = 12; // Start slowing down here

  function spawnLoop(dt) {
    const bubbleCount = state.bubbles.length;
    
    // Calculate density penalty
    let densityMultiplier = 1.0;
    if (bubbleCount >= CROWDED_THRESHOLD) {
      // Slow down spawning as we approach max bubbles
      const overflow = (bubbleCount - CROWDED_THRESHOLD) / (MAX_BUBBLES - CROWDED_THRESHOLD);
      densityMultiplier = 1.0 + (overflow * 3.0); // Up to 4x slower
    }
    
    // Don't spawn at all if we're at or above max
    if (bubbleCount >= MAX_BUBBLES) {
      return;
    }
    
    // Adjust spawn rate based on difficulty and density
    const currentInterval = (BASE_SPAWN_INTERVAL / difficultyLevel) * densityMultiplier;
    
    spawnTimer += dt;
    if (spawnTimer >= currentInterval) {
      spawnTimer = 0;
      spawnBubble();
      
      // At higher difficulties, sometimes spawn multiple bubbles
      // But respect density limits
      if (difficultyLevel >= 2.0 && Math.random() < 0.3 && bubbleCount < CROWDED_THRESHOLD) {
        setTimeout(() => spawnBubble(), 100);
      }
      if (difficultyLevel >= 2.5 && Math.random() < 0.2 && bubbleCount < CROWDED_THRESHOLD - 2) {
        setTimeout(() => spawnBubble(), 200);
      }
    }
  }

  // ---------------- Animation Loop ----------------
  let last = performance.now();

  function frame(now) {
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    adjustDifficulty(dt);
    update(dt);
    spawnLoop(dt);
    draw();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // Start with a few bubbles
  for (let i=0; i<3; i++) {
    setTimeout(() => spawnBubble(), i * 300);
  }
})();
</script>
</body>
</html>


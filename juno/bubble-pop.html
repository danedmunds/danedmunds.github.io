<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Bubble Pop! (v16)</title>
  <style>
    html, body {
      margin: 0; height: 100%;
      background: linear-gradient(180deg, #0a0520 0%, #1a1540 100%);
      overflow: hidden;
      touch-action: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    canvas { display:block; width:100vw; height:100vh; }

    .score {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      
      font: 900 48px/1 system-ui;
      color: rgba(255,255,255,0.95);
      text-shadow: 0 4px 12px rgba(0,0,0,0.5),
                   0 0 20px rgba(140, 255, 210, 0.4);
      user-select: none;
      -webkit-user-select: none;
      pointer-events: none;
    }

    .combo {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      
      font: 700 24px/1 system-ui;
      color: rgba(255, 200, 100, 0.95);
      text-shadow: 0 2px 8px rgba(0,0,0,0.5);
      user-select: none;
      -webkit-user-select: none;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .combo.active { opacity: 1; }
  </style>
</head>
<body>
  <div id="score" class="score">0</div>
  <div id="combo" class="combo"></div>
  <canvas id="c"></canvas>

<script>
(() => {
  // ---------------- Canvas setup ----------------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: true });

  function resize() {
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener("resize", resize, { passive: true });
  resize();

  // ---------------- Helpers ----------------
  const rand = (a,b)=>a+Math.random()*(b-a);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;

  // ---------------- Game State ----------------
  let score = 0;
  let combo = 0;
  let comboTimer = 0;
  let bubblesPopped = 0;
  let bubblesEscaped = 0;
  let performanceCheckTimer = 0;
  let difficultyLevel = 1.0; // Multiplier for spawn rate
  
  const scoreEl = document.getElementById("score");
  const comboEl = document.getElementById("combo");

  const state = {
    bubbles: [],
    particles: [],
    chainDisplays: [], // Active chain reaction displays
  };
  
  let activeChains = new Map(); // chainId -> { count, displayIndex, originX, originY }

  function updateScore(points) {
    score += points;
    scoreEl.textContent = score;
    
    bubblesPopped++;
    
    combo++;
    comboTimer = 2.0;
    if (combo > 1) {
      comboEl.textContent = `${combo}x COMBO!`;
      comboEl.classList.add("active");
    }
  }

  function bubbleEscaped() {
    bubblesEscaped++;
    combo = 0;
    comboEl.classList.remove("active");
  }

  // Dynamic difficulty adjustment
  function adjustDifficulty(dt) {
    performanceCheckTimer += dt;
    
    // Check performance every 5 seconds
    if (performanceCheckTimer >= 5.0) {
      performanceCheckTimer = 0;
      
      const total = bubblesPopped + bubblesEscaped;
      if (total > 0) {
        const successRate = bubblesPopped / total;
        
        // If popping 90%+ of bubbles, increase difficulty
        if (successRate >= 0.9 && difficultyLevel < 3.0) {
          difficultyLevel += 0.2;
        }
        // If missing 50%+ of bubbles, decrease difficulty
        else if (successRate < 0.5 && difficultyLevel > 0.5) {
          difficultyLevel -= 0.15;
        }
        // Moderate success, slight increase
        else if (successRate >= 0.75 && difficultyLevel < 2.5) {
          difficultyLevel += 0.1;
        }
        
        // Clamp difficulty
        difficultyLevel = clamp(difficultyLevel, 0.5, 3.0);
      }
      
      // Reset counters
      bubblesPopped = 0;
      bubblesEscaped = 0;
    }
  }

  // ---------------- Sound (Web Audio) ----------------
  let audioCtx = null;
  let audioPrimed = false;

  function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
    audioPrimed = true;
  }

  function playTone(freq, dur=0.08, type="sine", vol=0.05) {
    if (!audioPrimed) return;
    const t0 = audioCtx.currentTime;

    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    o.type = type;
    o.frequency.setValueAtTime(freq, t0);

    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

    o.connect(g);
    g.connect(audioCtx.destination);

    o.start(t0);
    o.stop(t0 + dur + 0.02);
  }

  // ---------------- Musical Songs System ----------------
  const songs = [
    {
      name: "Twinkle Twinkle Little Star",
      // C C G G A A G F F E E D D C G G F F E E D G G F F E E D C C G G A A G F F E E D D C
      notes: [
        262, 262, 392, 392, 440, 440, 392, // Twinkle twinkle little star
        349, 349, 330, 330, 294, 294, 262, // How I wonder what you are
        392, 392, 349, 349, 330, 330, 294, // Up above the world so high
        392, 392, 349, 349, 330, 330, 294, // Like a diamond in the sky
        262, 262, 392, 392, 440, 440, 392, // Twinkle twinkle little star
        349, 349, 330, 330, 294, 294, 262  // How I wonder what you are
      ]
    },
    {
      name: "Mary Had a Little Lamb",
      // E D C D E E E D D D E G G E D C D E E E E D D E D C
      notes: [
        330, 294, 262, 294, 330, 330, 330, // Mary had a little lamb
        294, 294, 294, // little lamb
        330, 392, 392, // little lamb
        330, 294, 262, 294, 330, 330, 330, 330, // Mary had a little lamb its
        294, 294, 330, 294, 262 // fleece was white as snow
      ]
    },
    {
      name: "FÃ¼r Elise",
      // E D# E D# E B D C A
      notes: [
        330, 311, 330, 311, 330, 247, 294, 262, 220, // Opening phrase
        262, 330, 220, 247, // Second phrase
        247, 330, 247, 330, 311, 330, 247, 294, 262, 220, // Repeat
        262, 330, 220, 247, // End phrase
        247, 294, 247, 330, 392 // Extension
      ]
    },
    {
      name: "Greensleeves",
      // A C D E F E D B G A B C B A G# A
      notes: [
        220, 262, 294, 330, 349, 330, 294, 247, 196, 220, 247, 262, // Alas my love
        247, 220, 208, 220, // you do me wrong
        262, 294, 330, 349, 330, 294, 247, 196, 220, 247, // to cast me off
        262, 247, 220, 175, 220, // discourteously
        262, 294, 330, 349, 392, 440, 392, 349 // Greensleeves...
      ]
    }
  ];

  let currentSongIndex = 0;
  let currentNoteIndex = 0;
  let songTitleDisplay = null;

  function initNewSong() {
    currentSongIndex = Math.floor(Math.random() * songs.length);
    currentNoteIndex = 0;
    showSongTitle(songs[currentSongIndex].name);
  }

  function showSongTitle(title) {
    // Remove old display if exists
    if (songTitleDisplay) {
      songTitleDisplay.remove();
    }
    
    // Create new display
    songTitleDisplay = document.createElement('div');
    songTitleDisplay.style.cssText = `
      position: fixed;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 100;
      font: 900 48px system-ui;
      color: rgba(255,255,255,0.95);
      text-shadow: 0 4px 16px rgba(0,0,0,0.6), 0 0 30px rgba(140, 255, 210, 0.6);
      text-align: center;
      pointer-events: none;
      opacity: 1;
      transition: opacity 1s ease;
    `;
    songTitleDisplay.textContent = title;
    document.body.appendChild(songTitleDisplay);
    
    // Fade out after 2 seconds
    setTimeout(() => {
      if (songTitleDisplay) {
        songTitleDisplay.style.opacity = '0';
        setTimeout(() => {
          if (songTitleDisplay) {
            songTitleDisplay.remove();
            songTitleDisplay = null;
          }
        }, 1000);
      }
    }, 2000);
  }

  function playNextNote() {
    if (!audioPrimed) return;
    
    const song = songs[currentSongIndex];
    const frequency = song.notes[currentNoteIndex];
    
    // Play the note LOUDER
    playTone(frequency, 0.3, "sine", 0.35); // Increased from 0.15 to 0.35
    
    // Move to next note
    currentNoteIndex++;
    
    // If song finished, start a new random song
    if (currentNoteIndex >= song.notes.length) {
      initNewSong();
    }
  }

  // Initialize first song
  initNewSong();

  // Different pop sounds - NOW UNUSED, REPLACED BY MUSICAL NOTES
  function playPopSound(type) {
    // This function is kept for compatibility but not used
    playNextNote();
  }

  // ---------------- Bubble Types ----------------
  const bubbleTypes = [
    { 
      name: "Standard", 
      color: [180, 220], // hue range
      size: [30, 50],
      speed: [0.8, 1.4],
      points: 10,
      explosionType: 0,
      weight: 40
    },
    { 
      name: "Fast", 
      color: [0, 40], // red-orange
      size: [20, 35],
      speed: [2.0, 3.0],
      points: 20,
      explosionType: 1,
      weight: 20
    },
    { 
      name: "Giant", 
      color: [280, 320], // purple-pink
      size: [60, 90],
      speed: [0.4, 0.7],
      points: 30,
      explosionType: 2,
      weight: 10
    },
    { 
      name: "Sparkler", 
      color: [40, 80], // yellow-gold
      size: [25, 40],
      speed: [1.0, 1.8],
      points: 25,
      explosionType: 3,
      weight: 15
    },
    { 
      name: "Wobbler", 
      color: [120, 180], // green-cyan
      size: [35, 55],
      speed: [0.6, 1.2],
      points: 15,
      explosionType: 4,
      weight: 20
    },
    { 
      name: "Tiny", 
      color: [260, 300], // purple-blue
      size: [15, 25],
      speed: [2.5, 4.0],
      points: 35,
      explosionType: 5,
      weight: 8
    },
    { 
      name: "Crackler", 
      color: [320, 360], // pink-red
      size: [40, 60],
      speed: [1.2, 2.0],
      points: 22,
      explosionType: 6,
      weight: 12
    },
  ];

  function getRandomBubbleType() {
    const totalWeight = bubbleTypes.reduce((sum, t) => sum + t.weight, 0);
    let r = Math.random() * totalWeight;
    for (const type of bubbleTypes) {
      r -= type.weight;
      if (r <= 0) return type;
    }
    return bubbleTypes[0];
  }

  // ---------------- Spawn Bubbles ----------------
  function spawnBubble() {
    const type = getRandomBubbleType();
    const hue = rand(type.color[0], type.color[1]);
    const r = rand(type.size[0], type.size[1]);
    const speed = rand(type.speed[0], type.speed[1]);
    
    // 70% from bottom, 30% from sides
    const spawnFromSide = Math.random() < 0.3;
    
    let x, y, vx, vy;
    
    if (spawnFromSide) {
      // Spawn from left or right side
      const fromLeft = Math.random() < 0.5;
      x = fromLeft ? -r - 10 : innerWidth + r + 10;
      y = rand(innerHeight * 0.3, innerHeight - r - 20); // Middle to bottom
      vx = fromLeft ? rand(1.5, 3.0) : rand(-3.0, -1.5); // Blow across screen
      vy = rand(-1.5, -0.5); // Float upward gently
    } else {
      // Spawn from bottom (original)
      x = rand(r + 20, innerWidth - r - 20);
      y = innerHeight + r + 10;
      vx = rand(-0.3, 0.3);
      vy = -speed;
    }
    
    state.bubbles.push({
      x,
      y,
      r,
      vy,
      vx,
      life: 1.0,
      phase: rand(0, Math.PI*2),
      wiggleSpeed: rand(0.5, 2.0),
      wiggleAmp: rand(0.5, 2.0),
      hue,
      type,
    });
  }

  // ---------------- Explosion Types ----------------
  function explodeBubble(bubble) {
    const x = bubble.x;
    const y = bubble.y;
    const r = bubble.r;
    const type = bubble.type.explosionType;
    const hue = bubble.hue;

    playPopSound(type);

    switch(type) {
      case 0: // Standard burst - MORE PARTICLES, RAINBOW COLORS
        for (let i=0; i<50; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(2, 9);
          const layer = i % 3;
          // Mix circles and stars
          const kind = i % 4 === 0 ? "star" : "circle";
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: kind === "circle" ? rand(2, 6) : undefined,
            size: kind === "star" ? rand(3, 7) : undefined,
            rot: kind === "star" ? rand(0, Math.PI*2) : undefined,
            vr: kind === "star" ? rand(-10, 10) : undefined,
            twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
            life: rand(0.5, 1.2),
            hue: hue + rand(-60, 60),
            gravity: 0.8,
            fadeType: layer, // 0=linear, 1=slow-start, 2=fast-start
          });
        }
        // Add inner spray of different color with triangles
        for (let i=0; i<20; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(1, 4);
          const kind = i % 3 === 0 ? "triangle" : "circle";
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(3, 8),
            rot: kind === "triangle" ? rand(0, Math.PI*2) : undefined,
            vr: kind === "triangle" ? rand(-8, 8) : undefined,
            life: rand(0.6, 1.0),
            hue: (hue + 180) % 360, // complementary color
            gravity: 0.5,
            fadeType: 1,
          });
        }
        break;

      case 1: // Sharp shards - MORE SHARDS, COLORFUL, WITH STARS
        for (let i=0; i<60; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(4, 14);
          state.particles.push({
            kind: "shard",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            w: rand(2, 5),
            h: rand(8, 20),
            rot: a,
            vr: rand(-12, 12),
            life: rand(0.4, 0.9),
            hue: hue + rand(-90, 90),
            gravity: 0.6,
            fadeType: i % 2,
          });
        }
        // Add stars and diamonds
        for (let i=0; i<30; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(6, 12);
          const kind = i % 2 === 0 ? "star" : "diamond";
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            size: rand(4, 8),
            rot: rand(0, Math.PI*2),
            vr: rand(-15, 15),
            twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
            life: rand(0.3, 0.6),
            hue: rand(0, 360),
            gravity: 1.0,
            fadeType: 2,
          });
        }
        break;

      case 2: // Giant slow rings - MORE RINGS AND COLORS WITH SHOCKWAVE
        // Create a unique chain ID for this Giant bubble's chain reaction
        const chainId = Symbol();
        
        // Create initial chain display at origin
        createChainDisplay(x, y, 0, chainId);
        
        // Create shockwave rings that can pop other bubbles
        for (let i=0; i<5; i++) {
          setTimeout(() => {
            const shockwave = {
              kind: "ring",
              x, y,
              r: r * 0.3,
              growSpeed: rand(3, 6),
              life: rand(0.8, 1.4),
              hue: hue + i * 30,
              fadeType: i % 3,
              isShockwave: true, // Mark as shockwave
              origin: { x, y },
              chainId: chainId, // Assign chain ID
            };
            state.particles.push(shockwave);
          }, i * 60);
        }
        // Lots of colorful debris with varied shapes
        for (let i=0; i<80; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(1, 5);
          const colorShift = (i / 80) * 360; // full spectrum
          const shapeType = Math.floor(i / 20); // 4 shape types
          let kind;
          if (shapeType === 0) kind = "circle";
          else if (shapeType === 1) kind = "star";
          else if (shapeType === 2) kind = "triangle";
          else kind = "diamond";
          
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: kind === "circle" ? rand(3, 10) : undefined,
            size: kind !== "circle" ? rand(4, 9) : undefined,
            rot: kind !== "circle" ? rand(0, Math.PI*2) : undefined,
            vr: kind !== "circle" ? rand(-10, 10) : undefined,
            twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
            life: rand(0.6, 1.4),
            hue: (hue + colorShift) % 360,
            gravity: 0.3,
            fadeType: Math.floor(i / 27),
          });
        }
        // Add some glowing orbs
        for (let i=0; i<15; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(2, 4);
          state.particles.push({
            kind: "glow",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(6, 12),
            life: rand(0.8, 1.6),
            hue: hue + rand(-60, 60),
            gravity: 0.2,
            fadeType: 1,
          });
        }
        break;

      case 3: // Sparkly stars - TONS OF SPARKLES
        for (let i=0; i<100; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(3, 15);
          const ring = Math.floor(i / 20); // 5 rings of different colors
          state.particles.push({
            kind: "star",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            size: rand(3, 10),
            rot: rand(0, Math.PI*2),
            vr: rand(-15, 15),
            life: rand(0.5, 1.2),
            hue: (hue + ring * 72) % 360, // golden angle distribution
            gravity: 0.7,
            twinkle: rand(0, Math.PI*2),
            fadeType: ring % 3,
          });
        }
        // Add tiny fast sparkles
        for (let i=0; i<50; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(8, 18);
          state.particles.push({
            kind: "circle",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(1, 2),
            life: rand(0.3, 0.6),
            hue: rand(0, 360),
            gravity: 1.2,
            fadeType: 2,
          });
        }
        break;

      case 4: // Wobbling blobs - MORE VARIED BLOBS
        for (let i=0; i<50; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(1.5, 7);
          state.particles.push({
            kind: "blob",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(4, 14),
            life: rand(0.7, 1.5),
            hue: hue + rand(-120, 120),
            gravity: 0.7,
            phase: rand(0, Math.PI*2),
            wobbleSpeed: rand(3, 10),
            fadeType: i % 3,
          });
        }
        // Add contrasting color particles with varied shapes
        for (let i=0; i<30; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(3, 8);
          const kind = i % 3 === 0 ? "star" : (i % 3 === 1 ? "diamond" : "circle");
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: kind === "circle" ? rand(2, 6) : undefined,
            size: kind !== "circle" ? rand(3, 7) : undefined,
            rot: kind !== "circle" ? rand(0, Math.PI*2) : undefined,
            vr: kind !== "circle" ? rand(-12, 12) : undefined,
            twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
            life: rand(0.5, 1.0),
            hue: (hue + 180) % 360,
            gravity: 0.9,
            fadeType: 1,
          });
        }
        break;

      case 5: // Tiny fast confetti - MASSIVE CONFETTI STORM
        for (let i=0; i<120; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(8, 20);
          state.particles.push({
            kind: "confetti",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            w: rand(2, 5),
            h: rand(6, 14),
            rot: rand(0, Math.PI*2),
            vr: rand(-25, 25),
            life: rand(0.4, 1.0),
            hue: rand(0, 360), // fully random colors
            gravity: 1.4,
            fadeType: i % 3,
          });
        }
        // Add rainbow circles and other shapes
        for (let i=0; i<40; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(10, 18);
          const kind = i % 4 === 0 ? "star" : (i % 4 === 1 ? "diamond" : (i % 4 === 2 ? "triangle" : "circle"));
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: kind === "circle" ? rand(1, 3) : undefined,
            size: kind !== "circle" ? rand(2, 5) : undefined,
            rot: kind !== "circle" ? rand(0, Math.PI*2) : undefined,
            vr: kind !== "circle" ? rand(-20, 20) : undefined,
            twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
            life: rand(0.3, 0.7),
            hue: (i / 40) * 360, // full spectrum
            gravity: 1.6,
            fadeType: 2,
          });
        }
        break;

      case 6: // Crackle with trails - MORE TRAILS, MORE COLORS
        for (let i=0; i<70; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(4, 12);
          state.particles.push({
            kind: "trail",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(2, 6),
            life: rand(0.6, 1.4),
            hue: hue + rand(-90, 90),
            gravity: 1.0,
            trail: [{x, y}],
            fadeType: i % 3,
          });
        }
        // Add explosive shards
        for (let i=0; i<40; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(6, 14);
          state.particles.push({
            kind: "shard",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            w: rand(3, 6),
            h: rand(10, 18),
            rot: a,
            vr: rand(-15, 15),
            life: rand(0.5, 1.0),
            hue: (hue + i * 9) % 360, // rainbow spiral
            gravity: 0.8,
            fadeType: 1,
          });
        }
        // Add glowing core particles
        for (let i=0; i<20; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(2, 6);
          state.particles.push({
            kind: "glow",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(4, 10),
            life: rand(0.7, 1.3),
            hue: hue + rand(-45, 45),
            gravity: 0.5,
            fadeType: 0,
          });
        }
        break;
    }
  }

  // Create a scaled shockwave based on bubble size
  function createScaledShockwave(x, y, bubbleRadius, hue, chainId = null) {
    // Scale the shockwave properties based on bubble size
    // Smaller bubbles = smaller, faster shockwaves
    // Larger bubbles = larger, slower shockwaves
    const sizeScale = bubbleRadius / 50; // Normalize to typical bubble size
    const numRings = Math.max(1, Math.floor(sizeScale * 3)); // 1-3 rings based on size
    const maxRadius = bubbleRadius * 3; // Shockwave reaches 3x bubble radius
    
    for (let i = 0; i < numRings; i++) {
      setTimeout(() => {
        const shockwave = {
          kind: "ring",
          x, y,
          r: bubbleRadius * 0.2,
          growSpeed: (3 + sizeScale * 2) * (1 + i * 0.2), // Faster for bigger bubbles
          life: 0.6 + sizeScale * 0.4, // Lives longer based on size
          hue: hue + i * 40,
          fadeType: i % 3,
          isShockwave: true,
          origin: { x, y },
          maxRadius: maxRadius, // Stop expanding at this radius
          chainId: chainId, // Propagate chain ID
        };
        state.particles.push(shockwave);
      }, i * 40);
    }
  }

  // Create intense chain display text
  function createChainDisplay(x, y, count, chainId) {
    const displayIndex = state.chainDisplays.length;
    state.chainDisplays.push({
      x,
      y: y - 20, // Start slightly above
      count,
      life: 1.5, // Lives for 1.5 seconds
      scale: 0.5, // Start small
      maxScale: 1.5 + count * 0.2, // Bigger for longer chains
      vy: -50, // Float upward
    });
    
    // Track this chain
    activeChains.set(chainId, {
      count,
      displayIndex,
      originX: x,
      originY: y,
    });
    
    // Clean up chain data when display expires
    setTimeout(() => {
      activeChains.delete(chainId);
    }, 1500);
  }

  // ---------------- Input Handling ----------------
  let isDragging = false;
  let lastDragCheck = { x: 0, y: 0 };

  function handlePointerDown(e) {
    if (!audioPrimed) {
      ensureAudio();
      playPopSound(0);
    }

    const x = e.clientX;
    const y = e.clientY;
    
    isDragging = true;
    lastDragCheck = { x, y };

    // Check for bubble hit
    checkBubbleHit(x, y);
  }

  function handlePointerMove(e) {
    if (!isDragging) return;
    
    const x = e.clientX;
    const y = e.clientY;
    
    // Check for bubbles along the drag path
    const dx = x - lastDragCheck.x;
    const dy = y - lastDragCheck.y;
    const dist = Math.hypot(dx, dy);
    
    // Check multiple points along the drag path
    const steps = Math.max(1, Math.floor(dist / 10));
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const checkX = lastDragCheck.x + dx * t;
      const checkY = lastDragCheck.y + dy * t;
      checkBubbleHit(checkX, checkY);
    }
    
    lastDragCheck = { x, y };
  }

  function handlePointerUp(e) {
    isDragging = false;
  }

  function checkBubbleHit(x, y) {
    // Check for bubble hit
    for (let i = state.bubbles.length - 1; i >= 0; i--) {
      const b = state.bubbles[i];
      const dx = x - b.x;
      const dy = y - b.y;
      const dist = Math.hypot(dx, dy);

      if (dist < b.r) {
        explodeBubble(b);
        const pointsEarned = b.type.points * Math.max(1, combo);
        updateScore(pointsEarned);
        state.bubbles.splice(i, 1);
      }
    }
  }

  canvas.addEventListener("pointerdown", handlePointerDown, { passive: true });
  canvas.addEventListener("pointermove", handlePointerMove, { passive: true });
  canvas.addEventListener("pointerup", handlePointerUp, { passive: true });
  canvas.addEventListener("pointercancel", handlePointerUp, { passive: true });

  // ---------------- Update ----------------
  function update(dt) {
    // Update bubbles
    for (let i = state.bubbles.length - 1; i >= 0; i--) {
      const b = state.bubbles[i];
      b.phase += dt * b.wiggleSpeed;
      b.x += (b.vx + Math.sin(b.phase) * b.wiggleAmp) * 60 * dt;
      b.y += b.vy * 60 * dt;

      // Remove if off screen
      if (b.y + b.r < -10) {
        state.bubbles.splice(i, 1);
        bubbleEscaped();
      }
    }

    // Update particles
    for (let i = state.particles.length - 1; i >= 0; i--) {
      const p = state.particles[i];
      p.life -= dt;

      if (p.kind === "ring") {
        const oldR = p.r;
        p.r += p.growSpeed * 60 * dt;
        
        // Stop growing if we hit max radius
        if (p.maxRadius && p.r > p.maxRadius) {
          p.r = p.maxRadius;
          p.life = Math.min(p.life, 0.2); // Start fading out quickly
        }
        
        // Check for shockwave collisions with bubbles (only check newly expanded area)
        if (p.isShockwave && p.origin && p.r <= (p.maxRadius || Infinity)) {
          for (let j = state.bubbles.length - 1; j >= 0; j--) {
            const b = state.bubbles[j];
            const dx = b.x - p.origin.x;
            const dy = b.y - p.origin.y;
            const distFromCenter = Math.hypot(dx, dy);
            
            // Check if bubble is within the expanding ring (with some thickness)
            const ringThickness = 20;
            if (Math.abs(distFromCenter - p.r) < ringThickness + b.r) {
              const chainId = p.chainId;
              
              if (chainId) {
                // Increment chain count
                const chainData = activeChains.get(chainId);
                if (chainData) {
                  chainData.count++;
                  // Update the existing display
                  if (state.chainDisplays[chainData.displayIndex]) {
                    state.chainDisplays[chainData.displayIndex].count = chainData.count;
                    state.chainDisplays[chainData.displayIndex].life = 1.5; // Reset life
                  }
                }
              }
              
              // Pop the bubble!
              explodeBubble(b);
              const pointsEarned = Math.floor(b.type.points * 0.5); // Half points for chain pops
              updateScore(pointsEarned);
              
              // Create a scaled shockwave from this bubble with chain ID
              createScaledShockwave(b.x, b.y, b.r, b.hue, chainId);
              
              state.bubbles.splice(j, 1);
            }
          }
        }
      } else {
        p.x += p.vx * 60 * dt;
        p.y += p.vy * 60 * dt;
        
        if (p.gravity !== undefined) {
          p.vy += p.gravity * dt;
        }

        if (p.vr !== undefined) {
          p.rot += p.vr * dt;
        }

        if (p.kind === "blob") {
          p.phase += dt * p.wobbleSpeed;
        }

        if (p.kind === "star") {
          p.twinkle += dt * 10;
        }

        if (p.kind === "trail") {
          p.trail.push({x: p.x, y: p.y});
          if (p.trail.length > 8) p.trail.shift();
        }

        // Drag
        p.vx *= (1 - 0.8 * dt);
        p.vy *= (1 - 0.8 * dt);
      }

      if (p.life <= 0) {
        state.particles.splice(i, 1);
      }
    }

    // Combo timer
    if (comboTimer > 0) {
      comboTimer -= dt;
      if (comboTimer <= 0) {
        combo = 0;
        comboEl.classList.remove("active");
      }
    }
    
    // Update chain displays
    for (let i = state.chainDisplays.length - 1; i >= 0; i--) {
      const d = state.chainDisplays[i];
      d.life -= dt;
      d.y += d.vy * dt;
      
      // Update maxScale as count increases
      d.maxScale = 1.5 + d.count * 0.2;
      
      // Animate scale (pop in, then settle)
      const lifeProgress = 1 - (d.life / 1.5);
      if (lifeProgress < 0.2) {
        // Pop in
        d.scale = lerp(0.5, d.maxScale, lifeProgress / 0.2);
      } else if (lifeProgress < 0.4) {
        // Settle back
        d.scale = lerp(d.maxScale, d.maxScale * 0.9, (lifeProgress - 0.2) / 0.2);
      } else {
        // Stay at settled size, but grow if count increases
        const targetScale = d.maxScale * 0.9;
        d.scale = lerp(d.scale, targetScale, dt * 10); // Smooth interpolation
      }
      
      // Slow down upward movement
      d.vy *= (1 - 2.0 * dt);
      
      // Remove if dead
      if (d.life <= 0) {
        state.chainDisplays.splice(i, 1);
      }
    }
  }

  // ---------------- Draw ----------------
  function draw() {
    // Background
    ctx.fillStyle = "rgba(10, 5, 32, 0.15)";
    ctx.fillRect(0, 0, innerWidth, innerHeight);

    // Draw particles
    ctx.save();
    ctx.globalCompositeOperation = "lighter";

    for (const p of state.particles) {
      // Different fade types
      let a;
      const fadeType = p.fadeType || 0;
      if (fadeType === 0) {
        // Linear fade
        a = clamp(p.life / 0.4, 0, 1);
      } else if (fadeType === 1) {
        // Slow start fade (stays bright longer)
        const t = clamp(p.life / 0.5, 0, 1);
        a = t * t;
      } else {
        // Fast start fade (quick fade out)
        const t = clamp(p.life / 0.3, 0, 1);
        a = Math.sqrt(t);
      }

      if (p.kind === "circle") {
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 85%, 65%)`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.fill();
      } 
      else if (p.kind === "glow") {
        // Glowing orb with radial gradient
        ctx.globalAlpha = a * 0.8;
        const grd = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r);
        grd.addColorStop(0, `hsla(${p.hue}, 95%, 85%, 1)`);
        grd.addColorStop(0.5, `hsla(${p.hue}, 90%, 70%, 0.6)`);
        grd.addColorStop(1, `hsla(${p.hue}, 85%, 60%, 0)`);
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r * 1.5, 0, Math.PI*2);
        ctx.fill();
      }
      else if (p.kind === "ring") {
        ctx.globalAlpha = a * 0.6;
        ctx.strokeStyle = `hsl(${p.hue}, 85%, 70%)`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.stroke();
      }
      else if (p.kind === "shard") {
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 90%, 70%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
        ctx.restore();
      }
      else if (p.kind === "star") {
        const tw = p.twinkle !== undefined ? (0.7 + 0.3 * Math.sin(p.twinkle)) : 1;
        ctx.globalAlpha = a * tw;
        ctx.fillStyle = `hsl(${p.hue}, 95%, 75%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot || 0);
        ctx.beginPath();
        for (let i=0; i<5; i++) {
          const ang = (i/5) * Math.PI * 2;
          const r = i % 2 === 0 ? p.size : p.size * 0.4;
          ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      else if (p.kind === "triangle") {
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 90%, 70%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot || 0);
        ctx.beginPath();
        const s = p.r || p.size;
        ctx.moveTo(0, -s);
        ctx.lineTo(s * 0.866, s * 0.5);
        ctx.lineTo(-s * 0.866, s * 0.5);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      else if (p.kind === "diamond") {
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 92%, 72%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot || 0);
        ctx.beginPath();
        const s = p.size || p.r;
        ctx.moveTo(0, -s);
        ctx.lineTo(s * 0.6, 0);
        ctx.lineTo(0, s);
        ctx.lineTo(-s * 0.6, 0);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      else if (p.kind === "blob") {
        const wobble = Math.sin(p.phase) * 0.2 + 1;
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 85%, 65%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.scale(wobble, 1/wobble);
        ctx.beginPath();
        ctx.arc(0, 0, p.r, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      else if (p.kind === "confetti") {
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 90%, 65%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
        ctx.restore();
      }
      else if (p.kind === "trail") {
        ctx.globalAlpha = a;
        ctx.strokeStyle = `hsl(${p.hue}, 90%, 70%)`;
        ctx.lineWidth = p.r;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.beginPath();
        for (let i=0; i<p.trail.length; i++) {
          const pt = p.trail[i];
          if (i === 0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
        }
        ctx.stroke();
        
        // Draw head
        ctx.fillStyle = `hsl(${p.hue}, 95%, 75%)`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r * 1.2, 0, Math.PI*2);
        ctx.fill();
      }
    }
    ctx.restore();

    // Draw bubbles
    ctx.save();
    const now = performance.now();
    for (const b of state.bubbles) {
      const hue = b.hue;
      
      // All bubbles create shockwaves, so they all pulse!
      // Pulse effect based on time and bubble size
      const pulseSpeed = 2.0 + (b.r / 50); // Bigger bubbles pulse slower
      const pulse = Math.sin(now * 0.003 * pulseSpeed) * 0.15 + 1; // 0.85 to 1.15
      
      // Outer glow (pulses)
      ctx.globalAlpha = 0.3 * pulse;
      const glowSize = b.r * 1.3 * pulse;
      const glow = ctx.createRadialGradient(b.x, b.y, b.r * 0.5, b.x, b.y, glowSize);
      glow.addColorStop(0, `hsla(${hue}, 85%, 70%, 0.4)`);
      glow.addColorStop(1, `hsla(${hue}, 85%, 70%, 0)`);
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(b.x, b.y, glowSize, 0, Math.PI*2);
      ctx.fill();
      
      // Pulsing energy ring around bubble
      ctx.globalAlpha = 0.4 * pulse;
      ctx.strokeStyle = `hsla(${hue}, 90%, 75%, ${0.6 * pulse})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r * (1.1 + pulse * 0.1), 0, Math.PI*2);
      ctx.stroke();

      // Main bubble
      ctx.globalAlpha = 0.6;
      ctx.strokeStyle = `hsla(${hue}, 80%, 65%, 0.9)`;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.stroke();

      // Highlight
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = `hsla(${hue}, 90%, 85%, 0.6)`;
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.3, b.y - b.r*0.3, b.r*0.3, 0, Math.PI*2);
      ctx.fill();

      // Small highlight
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = `hsla(${hue}, 95%, 95%, 0.8)`;
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.4, b.y - b.r*0.4, b.r*0.15, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
    
    // Draw chain reaction displays (on top of everything)
    ctx.save();
    for (const d of state.chainDisplays) {
      const alpha = clamp(d.life / 0.5, 0, 1); // Fade out in last 0.5 seconds
      
      ctx.globalAlpha = alpha;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      
      // Calculate colors based on chain length
      const hue = 30 + d.count * 15; // Yellow to red spectrum
      
      // Outer glow
      ctx.shadowBlur = 20 * d.scale;
      ctx.shadowColor = `hsla(${hue}, 100%, 50%, ${alpha})`;
      
      // Main text
      const fontSize = Math.floor(40 * d.scale);
      ctx.font = `900 ${fontSize}px system-ui, -apple-system, sans-serif`;
      ctx.fillStyle = `hsla(${hue}, 100%, 60%, 1)`;
      ctx.fillText(`${d.count}x CHAIN!`, d.x, d.y);
      
      // Inner highlight
      ctx.shadowBlur = 0;
      ctx.fillStyle = `hsla(${hue + 30}, 100%, 85%, ${alpha * 0.8})`;
      ctx.fillText(`${d.count}x CHAIN!`, d.x, d.y - 2);
      
      // Impact lines (if chain is big enough)
      if (d.count >= 3) {
        ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${alpha * 0.6})`;
        ctx.lineWidth = 3 * d.scale;
        const lineLength = 30 * d.scale;
        for (let i = 0; i < 4; i++) {
          const angle = (i / 4) * Math.PI * 2 + performance.now() * 0.01;
          const x1 = d.x + Math.cos(angle) * (fontSize * 0.8);
          const y1 = d.y + Math.sin(angle) * (fontSize * 0.5);
          const x2 = d.x + Math.cos(angle) * (fontSize * 0.8 + lineLength);
          const y2 = d.y + Math.sin(angle) * (fontSize * 0.5 + lineLength);
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
      }
    }
    ctx.restore();
  }

  // ---------------- Bubble Spawner ----------------
  let spawnTimer = 0;
  const BASE_SPAWN_INTERVAL = 0.4; // Faster spawn! (was 0.8)
  const MAX_BUBBLES = 20; // Allow more bubbles (was 15)
  const CROWDED_THRESHOLD = 16; // Start slowing down here (was 12)

  function spawnLoop(dt) {
    const bubbleCount = state.bubbles.length;
    
    // Calculate density penalty
    let densityMultiplier = 1.0;
    if (bubbleCount >= CROWDED_THRESHOLD) {
      // Slow down spawning as we approach max bubbles
      const overflow = (bubbleCount - CROWDED_THRESHOLD) / (MAX_BUBBLES - CROWDED_THRESHOLD);
      densityMultiplier = 1.0 + (overflow * 3.0); // Up to 4x slower
    }
    
    // Don't spawn at all if we're at or above max
    if (bubbleCount >= MAX_BUBBLES) {
      return;
    }
    
    // Adjust spawn rate based on difficulty and density
    const currentInterval = (BASE_SPAWN_INTERVAL / difficultyLevel) * densityMultiplier;
    
    spawnTimer += dt;
    if (spawnTimer >= currentInterval) {
      spawnTimer = 0;
      spawnBubble();
      
      // At higher difficulties, sometimes spawn multiple bubbles
      // But respect density limits
      if (difficultyLevel >= 2.0 && Math.random() < 0.3 && bubbleCount < CROWDED_THRESHOLD) {
        setTimeout(() => spawnBubble(), 100);
      }
      if (difficultyLevel >= 2.5 && Math.random() < 0.2 && bubbleCount < CROWDED_THRESHOLD - 2) {
        setTimeout(() => spawnBubble(), 200);
      }
    }
  }

  // ---------------- Animation Loop ----------------
  let last = performance.now();

  function frame(now) {
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    adjustDifficulty(dt);
    update(dt);
    spawnLoop(dt);
    draw();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // Start with a few bubbles
  for (let i=0; i<3; i++) {
    setTimeout(() => spawnBubble(), i * 300);
  }
})();
</script>
</body>
</html>


<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Bubble Pop! (v24)</title>
  <style>
    html, body {
      margin: 0; height: 100%;
      background: linear-gradient(180deg, #0a0520 0%, #1a1540 100%);
      overflow: hidden;
      touch-action: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    canvas { display:block; width:100vw; height:100vh; }

    .score {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      
      font: 900 48px/1 system-ui;
      color: rgba(255,255,255,0.95);
      text-shadow: 0 4px 12px rgba(0,0,0,0.5),
                   0 0 20px rgba(140, 255, 210, 0.4);
      user-select: none;
      -webkit-user-select: none;
      pointer-events: none;
    }

    .combo {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      
      font: 700 24px/1 system-ui;
      color: rgba(255, 200, 100, 0.95);
      text-shadow: 0 2px 8px rgba(0,0,0,0.5);
      user-select: none;
      -webkit-user-select: none;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .combo.active { opacity: 1; }
  </style>
</head>
<body>
  <div id="score" class="score">0</div>
  <div id="combo" class="combo"></div>
  <canvas id="c"></canvas>

<script>
(() => {
  // ---------------- Canvas setup ----------------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: true });

  function resize() {
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener("resize", resize, { passive: true });
  resize();

  // ---------------- Helpers ----------------
  const rand = (a,b)=>a+Math.random()*(b-a);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;

  // ---------------- Game State ----------------
  let score = 0;
  let combo = 0;
  let comboTimer = 0;
  let bubblesPopped = 0;
  let bubblesEscaped = 0;
  let performanceCheckTimer = 0;
  let difficultyLevel = 1.0; // Multiplier for spawn rate
  
  const scoreEl = document.getElementById("score");
  const comboEl = document.getElementById("combo");

  const state = {
    bubbles: [],
    particles: [],
    chainDisplays: [], // Active chain reaction displays
    noteEffectParticles: [], // Particles for note visual effects
  };
  
  let activeChains = new Map(); // chainId -> { count, displayIndex, originX, originY }

  function updateScore(points) {
    score += points;
    scoreEl.textContent = score;
    
    bubblesPopped++;
    
    combo++;
    comboTimer = 2.0;
    if (combo > 1) {
      comboEl.textContent = `${combo}x COMBO!`;
      comboEl.classList.add("active");
    }
  }

  function bubbleEscaped() {
    bubblesEscaped++;
    combo = 0;
    comboEl.classList.remove("active");
  }

  // Dynamic difficulty adjustment
  function adjustDifficulty(dt) {
    performanceCheckTimer += dt;
    
    // Check performance every 5 seconds
    if (performanceCheckTimer >= 5.0) {
      performanceCheckTimer = 0;
      
      const total = bubblesPopped + bubblesEscaped;
      if (total > 0) {
        const successRate = bubblesPopped / total;
        
        // If popping 90%+ of bubbles, increase difficulty
        if (successRate >= 0.9 && difficultyLevel < 3.0) {
          difficultyLevel += 0.2;
        }
        // If missing 50%+ of bubbles, decrease difficulty
        else if (successRate < 0.5 && difficultyLevel > 0.5) {
          difficultyLevel -= 0.15;
        }
        // Moderate success, slight increase
        else if (successRate >= 0.75 && difficultyLevel < 2.5) {
          difficultyLevel += 0.1;
        }
        
        // Clamp difficulty
        difficultyLevel = clamp(difficultyLevel, 0.5, 3.0);
      }
      
      // Reset counters
      bubblesPopped = 0;
      bubblesEscaped = 0;
    }
  }

  // ---------------- Sound (Web Audio) ----------------
  let audioCtx = null;
  let audioPrimed = false;
  let activeAudioNodes = 0; // Track active nodes
  const MAX_AUDIO_NODES = 8; // Limit concurrent nodes for iOS

  function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
    audioPrimed = true;
  }
  
  // Periodically resume audio context (iOS fix)
  setInterval(() => {
    if (audioCtx && audioCtx.state === "suspended") {
      audioCtx.resume();
    }
  }, 1000);

  function playTone(freq, dur=0.08, type="sine", vol=0.05) {
    if (!audioPrimed) return;
    if (activeAudioNodes >= MAX_AUDIO_NODES) return; // Don't create too many
    
    try {
      // Resume if suspended
      if (audioCtx.state === "suspended") {
        audioCtx.resume();
      }
      
    const t0 = audioCtx.currentTime;

    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    o.type = type;
    o.frequency.setValueAtTime(freq, t0);

    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

    o.connect(g);
    g.connect(audioCtx.destination);

      activeAudioNodes++;

    o.start(t0);
    o.stop(t0 + dur + 0.02);
      
      // Clean up when done
      o.onended = () => {
        activeAudioNodes--;
        o.disconnect();
        g.disconnect();
      };
    } catch (e) {
      console.warn("Audio error:", e);
    }
  }

  // ---------------- Musical Songs System ----------------
  const songs = [
    {
      name: "Twinkle Twinkle Little Star",
      notes: [
        262, 262, 392, 392, 440, 440, 392,
        349, 349, 330, 330, 294, 294, 262,
        392, 392, 349, 349, 330, 330, 294,
        392, 392, 349, 349, 330, 330, 294,
        262, 262, 392, 392, 440, 440, 392,
        349, 349, 330, 330, 294, 294, 262
      ]
    },
    {
      name: "Mary Had a Little Lamb",
      notes: [
        330, 294, 262, 294, 330, 330, 330,
        294, 294, 294,
        330, 392, 392,
        330, 294, 262, 294, 330, 330, 330, 330,
        294, 294, 330, 294, 262
      ]
    },
    {
      name: "Für Elise",
      notes: [
        330, 311, 330, 311, 330, 247, 294, 262, 220,
        262, 330, 220, 247,
        247, 330, 247, 330, 311, 330, 247, 294, 262, 220,
        262, 330, 220, 247,
        247, 294, 247, 330, 392
      ]
    },
    {
      name: "Greensleeves",
      notes: [
        220, 262, 294, 330, 349, 330, 294, 247, 196, 220, 247, 262,
        247, 220, 208, 220,
        262, 294, 330, 349, 330, 294, 247, 196, 220, 247,
        262, 247, 220, 175, 220,
        262, 294, 330, 349, 392, 440, 392, 349
      ]
    },
    {
      name: "Row Row Row Your Boat",
      notes: [
        262, 262, 262, 294, 330,
        330, 294, 330, 349, 392,
        523, 523, 523, 392, 392, 392, 330, 330, 330, 262, 262, 262,
        392, 349, 330, 294, 262
      ]
    },
    {
      name: "The Wheels on the Bus",
      notes: [
        392, 392, 392, 330, 392, 440, 392,
        392, 392, 392, 330, 392, 440, 392,
        262, 262, 247, 220, 392,
        440, 440, 392
      ]
    },
    {
      name: "Old MacDonald Had a Farm",
      notes: [
        392, 392, 392, 294, 330, 330, 294,
        247, 247, 220, 220, 392,
        294, 294, 294, 294, 330, 330, 294,
        247, 247, 220, 220, 392
      ]
    },
    {
      name: "Itsy Bitsy Spider",
      notes: [
        392, 262, 262, 262, 294, 330, 330,
        330, 294, 262, 294, 330, 262,
        392, 392, 392, 440, 392, 330,
        330, 294, 262, 294, 330, 262
      ]
    },
    {
      name: "Baa Baa Black Sheep",
      notes: [
        262, 262, 392, 392, 440, 440, 392,
        349, 349, 330, 330, 294, 294, 262,
        392, 392, 349, 349, 330, 330, 294,
        392, 392, 349, 349, 330, 330, 294,
        262, 262, 392, 392, 440, 440, 392,
        349, 349, 330, 330, 294, 294, 262
      ]
    },
    {
      name: "London Bridge",
      notes: [
        392, 440, 392, 349, 330, 349, 392,
        294, 330, 349,
        330, 349, 392,
        392, 440, 392, 349, 330, 349, 392,
        294, 392, 330, 262
      ]
    },
    {
      name: "Hot Cross Buns",
      notes: [
        330, 294, 262,
        330, 294, 262,
        262, 262, 262, 262, 294, 294, 294, 294,
        330, 294, 262
      ]
    },
    {
      name: "Three Blind Mice",
      notes: [
        330, 294, 262,
        330, 294, 262,
        392, 349, 330,
        392, 349, 330,
        523, 523, 523, 392, 466, 440, 392, 349,
        523, 523, 523, 392, 466, 440, 392, 349,
        330, 294, 262
      ]
    },
    {
      name: "Happy Birthday",
      notes: [
        262, 262, 294, 262, 349, 330,
        262, 262, 294, 262, 392, 349,
        262, 262, 523, 440, 349, 330, 294,
        466, 466, 440, 349, 392, 349
      ]
    },
    {
      name: "Jingle Bells",
      notes: [
        330, 330, 330,
        330, 330, 330,
        330, 392, 262, 294, 330,
        349, 349, 349, 349, 349, 330, 330, 330, 330, 294, 294, 330, 294, 392
      ]
    },
    {
      name: "Camptown Races",
      notes: [
        262, 330, 392, 392, 440, 392, 330,
        262, 330, 392, 392, 440, 392,
        392, 440, 392, 330, 262,
        330, 330, 294, 262, 262
      ]
    },
    {
      name: "Oh Susanna",
      notes: [
        262, 294, 330, 392, 392, 440, 392, 330, 262, 294, 330, 330, 294, 262, 294, 330,
        392, 440, 440, 392, 330, 262, 294, 330, 330, 294, 262, 220, 262
      ]
    },
    {
      name: "Ode to Joy",
      notes: [
        330, 330, 349, 392, 392, 349, 330, 294, 262, 262, 294, 330, 330, 294, 294,
        330, 330, 349, 392, 392, 349, 330, 294, 262, 262, 294, 330, 294, 262, 262
      ]
    },
    {
      name: "Brahms Lullaby",
      notes: [
        392, 330, 392, 330, 392, 330, 262,
        330, 294, 330, 349, 294, 247,
        392, 330, 392, 330, 392, 330, 262,
        330, 294, 262, 247, 262
      ]
    },
    {
      name: "Swan Lake Theme",
      notes: [
        330, 415, 440, 494, 523, 494, 440, 415,
        349, 392, 349, 330, 294, 262
      ]
    },
    {
      name: "Canon in D",
      notes: [
        370, 392, 440, 494, 440, 392, 370, 330,
        294, 330, 370, 392, 370, 330, 294, 277
      ]
    },
    {
      name: "Frère Jacques",
      notes: [
        262, 294, 330, 262,
        262, 294, 330, 262,
        330, 349, 392,
        330, 349, 392,
        392, 440, 392, 349, 330, 262,
        392, 440, 392, 349, 330, 262,
        262, 392, 262,
        262, 392, 262
      ]
    },
    {
      name: "Yankee Doodle",
      notes: [
        262, 262, 294, 330, 262, 330, 294,
        392, 262, 262, 294, 330, 262, 247,
        262, 262, 294, 330, 349, 330, 294, 262,
        392, 370, 392, 440, 494, 523
      ]
    },
    {
      name: "Amazing Grace",
      notes: [
        262, 349, 440, 523, 349, 440,
        523, 587, 523, 440, 349,
        392, 349,
        262, 349, 440, 523, 440,
        392, 349, 440, 523, 523,
        587, 523, 349
      ]
    },
    {
      name: "Pop Goes the Weasel",
      notes: [
        262, 294, 330, 262, 294, 330,
        330, 349, 392, 523,
        523, 392, 330, 262,
        262, 294, 330, 262, 294, 330,
        330, 349, 392, 523
      ]
    }
  ];

  let currentSongIndex = 0;
  let currentNoteIndex = 0;
  let songTitleDisplay = null;
  
  // Visual effects for notes
  let currentEffectIndex = 0;
  const noteEffects = [
    "bounce",
    "wobble", 
    "growPulse",
    "spinning",
    "sparkleBurst",
    "confettiPop",
    "bubbleTrail",
    "rainbowTrail",
    "pulsingGlow",
    "colorWave",
    "shimmer",
    "lightBeam",
    "bouncingSparkles",
    "growingGlow",
    "rainbowSpiral"
  ];

  function initNewSong() {
    currentSongIndex = Math.floor(Math.random() * songs.length);
    currentNoteIndex = 0;
    
    // Pick a random effect for this song
    currentEffectIndex = Math.floor(Math.random() * noteEffects.length);
    
    showSongTitle(songs[currentSongIndex].name);
  }

  function showSongTitle(title) {
    // Remove old display if exists
    if (songTitleDisplay) {
      songTitleDisplay.remove();
    }
    
    // Create new display
    songTitleDisplay = document.createElement('div');
    songTitleDisplay.style.cssText = `
      position: fixed;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 100;
      font: 900 48px system-ui;
      color: rgba(255,255,255,0.95);
      text-shadow: 0 4px 16px rgba(0,0,0,0.6), 0 0 30px rgba(140, 255, 210, 0.6);
      text-align: center;
      pointer-events: none;
      opacity: 1;
      transition: opacity 1s ease;
    `;
    songTitleDisplay.textContent = title;
    document.body.appendChild(songTitleDisplay);
    
    // Fade out after 2 seconds
    setTimeout(() => {
      if (songTitleDisplay) {
        songTitleDisplay.style.opacity = '0';
        setTimeout(() => {
          if (songTitleDisplay) {
            songTitleDisplay.remove();
            songTitleDisplay = null;
          }
        }, 1000);
      }
    }, 2000);
  }

  function playNextNote() {
    if (!audioPrimed) return;
    
    const song = songs[currentSongIndex];
    const frequency = song.notes[currentNoteIndex];
    
    // Play a musical note with proper envelope
    playMusicalNote(frequency);
    
    // Move to next note
    currentNoteIndex++;
    
    // If song finished, start a new random song (with new random effect)
    if (currentNoteIndex >= song.notes.length) {
      initNewSong();
    }
  }
  
  function playMusicalNote(freq) {
    if (!audioPrimed) return;
    if (activeAudioNodes >= MAX_AUDIO_NODES) return; // Don't create too many
    
    try {
      // Resume if suspended
      if (audioCtx.state === "suspended") {
        audioCtx.resume();
      }
      
      const t0 = audioCtx.currentTime;
      const duration = 0.5; // Longer note duration
      
      // Create oscillator for the note
      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      
      // Use triangle wave for a mellower, more musical sound
      osc.type = "triangle";
      osc.frequency.setValueAtTime(freq, t0);
      
      // Musical envelope: Attack - Decay - Sustain - Release (ADSR)
      const attackTime = 0.02;  // Quick attack
      const decayTime = 0.08;   // Slight decay
      const sustainLevel = 0.25; // Sustain volume
      const releaseTime = 0.15;  // Gentle release
      
      // Start silent
      gainNode.gain.setValueAtTime(0, t0);
      
      // Attack: ramp up quickly
      gainNode.gain.linearRampToValueAtTime(0.35, t0 + attackTime);
      
      // Decay: drop to sustain level
      gainNode.gain.linearRampToValueAtTime(sustainLevel, t0 + attackTime + decayTime);
      
      // Sustain: hold the level
      gainNode.gain.setValueAtTime(sustainLevel, t0 + duration - releaseTime);
      
      // Release: fade out smoothly
      gainNode.gain.linearRampToValueAtTime(0.0001, t0 + duration);
      
      // Connect and play
      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      
      activeAudioNodes++;
      
      osc.start(t0);
      osc.stop(t0 + duration);
      
      // Clean up when done
      osc.onended = () => {
        activeAudioNodes--;
        try {
          osc.disconnect();
          gainNode.disconnect();
        } catch (e) {
          // Already disconnected
        }
      };
    } catch (e) {
      console.warn("Audio error:", e);
    }
  }

  // Initialize first song
  initNewSong();

  // Different pop sounds - NOW UNUSED, REPLACED BY MUSICAL NOTES
  function playPopSound(type) {
    // This function is kept for compatibility but not used
    playNextNote();
  }

  // ---------------- Bubble Types ----------------
  const bubbleTypes = [
    { 
      name: "Standard", 
      color: [180, 220], // hue range
      size: [30, 50],
      speed: [0.8, 1.4],
      points: 10,
      explosionType: 0,
      weight: 40
    },
    { 
      name: "Fast", 
      color: [0, 40], // red-orange
      size: [20, 35],
      speed: [2.0, 3.0],
      points: 20,
      explosionType: 1,
      weight: 20
    },
    { 
      name: "Giant", 
      color: [280, 320], // purple-pink
      size: [60, 90],
      speed: [0.4, 0.7],
      points: 30,
      explosionType: 2,
      weight: 10
    },
    { 
      name: "Sparkler", 
      color: [40, 80], // yellow-gold
      size: [25, 40],
      speed: [1.0, 1.8],
      points: 25,
      explosionType: 3,
      weight: 15
    },
    { 
      name: "Wobbler", 
      color: [120, 180], // green-cyan
      size: [35, 55],
      speed: [0.6, 1.2],
      points: 15,
      explosionType: 4,
      weight: 20
    },
    { 
      name: "Tiny", 
      color: [260, 300], // purple-blue
      size: [15, 25],
      speed: [2.5, 4.0],
      points: 35,
      explosionType: 5,
      weight: 8
    },
    { 
      name: "Crackler", 
      color: [320, 360], // pink-red
      size: [40, 60],
      speed: [1.2, 2.0],
      points: 22,
      explosionType: 6,
      weight: 12
    },
    { 
      name: "Fireworks", 
      color: [0, 360], // rainbow - full spectrum
      size: [45, 65],
      speed: [0.9, 1.5],
      points: 40,
      explosionType: 7,
      weight: 5,
      hasStars: true // Visual indicator
    },
  ];

  function getRandomBubbleType() {
    const totalWeight = bubbleTypes.reduce((sum, t) => sum + t.weight, 0);
    let r = Math.random() * totalWeight;
    for (const type of bubbleTypes) {
      r -= type.weight;
      if (r <= 0) return type;
    }
    return bubbleTypes[0];
  }

  // ---------------- Spawn Bubbles ----------------
  function spawnBubble() {
    const type = getRandomBubbleType();
    const hue = rand(type.color[0], type.color[1]);
    const r = rand(type.size[0], type.size[1]);
    const speed = rand(type.speed[0], type.speed[1]);
    
    // 70% from bottom, 30% from sides
    const spawnFromSide = Math.random() < 0.3;
    
    let x, y, vx, vy;
    
    if (spawnFromSide) {
      // Spawn from left or right side
      const fromLeft = Math.random() < 0.5;
      x = fromLeft ? -r - 10 : innerWidth + r + 10;
      y = rand(innerHeight * 0.3, innerHeight - r - 20); // Middle to bottom
      vx = fromLeft ? rand(1.5, 3.0) : rand(-3.0, -1.5); // Blow across screen
      vy = rand(-1.5, -0.5); // Float upward gently
    } else {
      // Spawn from bottom (original)
      x = rand(r + 20, innerWidth - r - 20);
      y = innerHeight + r + 10;
      vx = rand(-0.3, 0.3);
      vy = -speed;
    }
    
    state.bubbles.push({
      x,
      y,
      r,
      vy,
      vx,
      life: 1.0,
      phase: rand(0, Math.PI*2),
      wiggleSpeed: rand(0.5, 2.0),
      wiggleAmp: rand(0.5, 2.0),
      hue,
      type,
    });
  }

  // ---------------- Explosion Types ----------------
  function explodeBubble(bubble) {
    const x = bubble.x;
    const y = bubble.y;
    const r = bubble.r;
    const type = bubble.type.explosionType;
    const hue = bubble.hue;

    playPopSound(type);

    switch(type) {
      case 0: // Standard burst - MORE PARTICLES, RAINBOW COLORS
        for (let i=0; i<50; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(2, 9);
          const layer = i % 3;
          // Mix circles and stars
          const kind = i % 4 === 0 ? "star" : "circle";
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: kind === "circle" ? rand(2, 6) : undefined,
            size: kind === "star" ? rand(3, 7) : undefined,
            rot: kind === "star" ? rand(0, Math.PI*2) : undefined,
            vr: kind === "star" ? rand(-10, 10) : undefined,
            twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
            life: rand(0.5, 1.2),
            hue: hue + rand(-60, 60),
            gravity: 0.8,
            fadeType: layer, // 0=linear, 1=slow-start, 2=fast-start
          });
        }
        // Add inner spray of different color with triangles
        for (let i=0; i<20; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(1, 4);
          const kind = i % 3 === 0 ? "triangle" : "circle";
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(3, 8),
            rot: kind === "triangle" ? rand(0, Math.PI*2) : undefined,
            vr: kind === "triangle" ? rand(-8, 8) : undefined,
            life: rand(0.6, 1.0),
            hue: (hue + 180) % 360, // complementary color
            gravity: 0.5,
            fadeType: 1,
          });
        }
        break;

      case 1: // Sharp shards - MORE SHARDS, COLORFUL, WITH STARS
        for (let i=0; i<60; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(4, 14);
          state.particles.push({
            kind: "shard",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            w: rand(2, 5),
            h: rand(8, 20),
            rot: a,
            vr: rand(-12, 12),
            life: rand(0.4, 0.9),
            hue: hue + rand(-90, 90),
            gravity: 0.6,
            fadeType: i % 2,
          });
        }
        // Add stars and diamonds
        for (let i=0; i<30; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(6, 12);
          const kind = i % 2 === 0 ? "star" : "diamond";
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            size: rand(4, 8),
            rot: rand(0, Math.PI*2),
            vr: rand(-15, 15),
            twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
            life: rand(0.3, 0.6),
            hue: rand(0, 360),
            gravity: 1.0,
            fadeType: 2,
          });
        }
        break;

      case 2: // Giant slow rings - MORE RINGS AND COLORS WITH SHOCKWAVE
        // Create a unique chain ID for this Giant bubble's chain reaction
        const chainId = Symbol();
        
        // Track this chain (but don't create display yet - wait for first hit)
        activeChains.set(chainId, {
          count: 0,
          displayIndex: -1,
          originX: x,
          originY: y,
        });
        
        // Create shockwave rings that can pop other bubbles
        for (let i=0; i<5; i++) {
          setTimeout(() => {
            const shockwave = {
              kind: "ring",
              x, y,
              r: r * 0.3,
              growSpeed: rand(3, 6),
              life: rand(0.8, 1.4),
              hue: hue + i * 30,
              fadeType: i % 3,
              isShockwave: true, // Mark as shockwave
              origin: { x, y },
              chainId: chainId, // Assign chain ID
            };
            state.particles.push(shockwave);
          }, i * 60);
        }
        // Lots of colorful debris with varied shapes
        for (let i=0; i<80; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(1, 5);
          const colorShift = (i / 80) * 360; // full spectrum
          const shapeType = Math.floor(i / 20); // 4 shape types
          let kind;
          if (shapeType === 0) kind = "circle";
          else if (shapeType === 1) kind = "star";
          else if (shapeType === 2) kind = "triangle";
          else kind = "diamond";
          
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: kind === "circle" ? rand(3, 10) : undefined,
            size: kind !== "circle" ? rand(4, 9) : undefined,
            rot: kind !== "circle" ? rand(0, Math.PI*2) : undefined,
            vr: kind !== "circle" ? rand(-10, 10) : undefined,
            twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
            life: rand(0.6, 1.4),
            hue: (hue + colorShift) % 360,
            gravity: 0.3,
            fadeType: Math.floor(i / 27),
          });
        }
        // Add some glowing orbs
        for (let i=0; i<15; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(2, 4);
          state.particles.push({
            kind: "glow",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(6, 12),
            life: rand(0.8, 1.6),
            hue: hue + rand(-60, 60),
            gravity: 0.2,
            fadeType: 1,
          });
        }
        break;

      case 3: // Sparkly stars - TONS OF SPARKLES
        for (let i=0; i<100; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(3, 15);
          const ring = Math.floor(i / 20); // 5 rings of different colors
          state.particles.push({
            kind: "star",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            size: rand(3, 10),
            rot: rand(0, Math.PI*2),
            vr: rand(-15, 15),
            life: rand(0.5, 1.2),
            hue: (hue + ring * 72) % 360, // golden angle distribution
            gravity: 0.7,
            twinkle: rand(0, Math.PI*2),
            fadeType: ring % 3,
          });
        }
        // Add tiny fast sparkles
        for (let i=0; i<50; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(8, 18);
          state.particles.push({
            kind: "circle",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(1, 2),
            life: rand(0.3, 0.6),
            hue: rand(0, 360),
            gravity: 1.2,
            fadeType: 2,
          });
        }
        break;

      case 4: // Wobbling blobs - MORE VARIED BLOBS
        for (let i=0; i<50; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(1.5, 7);
          state.particles.push({
            kind: "blob",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(4, 14),
            life: rand(0.7, 1.5),
            hue: hue + rand(-120, 120),
            gravity: 0.7,
            phase: rand(0, Math.PI*2),
            wobbleSpeed: rand(3, 10),
            fadeType: i % 3,
          });
        }
        // Add contrasting color particles with varied shapes
        for (let i=0; i<30; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(3, 8);
          const kind = i % 3 === 0 ? "star" : (i % 3 === 1 ? "diamond" : "circle");
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: kind === "circle" ? rand(2, 6) : undefined,
            size: kind !== "circle" ? rand(3, 7) : undefined,
            rot: kind !== "circle" ? rand(0, Math.PI*2) : undefined,
            vr: kind !== "circle" ? rand(-12, 12) : undefined,
            twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
            life: rand(0.5, 1.0),
            hue: (hue + 180) % 360,
            gravity: 0.9,
            fadeType: 1,
          });
        }
        break;

      case 5: // Tiny fast confetti - MASSIVE CONFETTI STORM
        for (let i=0; i<120; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(8, 20);
          state.particles.push({
            kind: "confetti",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            w: rand(2, 5),
            h: rand(6, 14),
            rot: rand(0, Math.PI*2),
            vr: rand(-25, 25),
            life: rand(0.4, 1.0),
            hue: rand(0, 360), // fully random colors
            gravity: 1.4,
            fadeType: i % 3,
          });
        }
        // Add rainbow circles and other shapes
        for (let i=0; i<40; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(10, 18);
          const kind = i % 4 === 0 ? "star" : (i % 4 === 1 ? "diamond" : (i % 4 === 2 ? "triangle" : "circle"));
          state.particles.push({
            kind,
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: kind === "circle" ? rand(1, 3) : undefined,
            size: kind !== "circle" ? rand(2, 5) : undefined,
            rot: kind !== "circle" ? rand(0, Math.PI*2) : undefined,
            vr: kind !== "circle" ? rand(-20, 20) : undefined,
            twinkle: kind === "star" ? rand(0, Math.PI*2) : undefined,
            life: rand(0.3, 0.7),
            hue: (i / 40) * 360, // full spectrum
            gravity: 1.6,
            fadeType: 2,
          });
        }
        break;

      case 6: // Crackle with trails - MORE TRAILS, MORE COLORS
        for (let i=0; i<70; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(4, 12);
          state.particles.push({
            kind: "trail",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(2, 6),
            life: rand(0.6, 1.4),
            hue: hue + rand(-90, 90),
            gravity: 1.0,
            trail: [{x, y}],
            fadeType: i % 3,
          });
        }
        // Add explosive shards
        for (let i=0; i<40; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(6, 14);
          state.particles.push({
            kind: "shard",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            w: rand(3, 6),
            h: rand(10, 18),
            rot: a,
            vr: rand(-15, 15),
            life: rand(0.5, 1.0),
            hue: (hue + i * 9) % 360, // rainbow spiral
            gravity: 0.8,
            fadeType: 1,
          });
        }
        // Add glowing core particles
        for (let i=0; i<20; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(2, 6);
          state.particles.push({
            kind: "glow",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(4, 10),
            life: rand(0.7, 1.3),
            hue: hue + rand(-45, 45),
            gravity: 0.5,
            fadeType: 0,
          });
        }
        break;
        
      case 7: // FIREWORKS PAINT - Shoots star projectiles!
        // Main firework burst with glow
        const count = rand(40, 60);
        const spread = rand(1.0, 2.0);
        const popSize = r;
        
        for (let i=0; i<count; i++) {
          const a = rand(0, Math.PI*2);
          const sp = rand(0.8, 6.0) * spread;
          const particleHue = (hue + rand(-30, 30)) % 360;
          
          state.particles.push({
            kind: "firework",
            x, y,
            vx: Math.cos(a)*sp,
            vy: Math.sin(a)*sp,
            r: rand(1.5, 4.0) * (popSize/48),
            life: rand(0.5, 1.2),
            hue: particleHue,
            gravity: 1.2,
            drag: 0.12, // Air resistance
            glow: rand(0.7, 1.0),
          });
        }
        
        // Shoot out 7 spinning star projectiles that can burst bubbles!
        for (let i=0; i<7; i++) {
          const a = (i / 7) * Math.PI * 2; // Evenly spaced
          const speed = rand(10, 15); // Even faster!
          state.particles.push({
            kind: "starProjectile",
            x, y,
            vx: Math.cos(a) * speed,
            vy: Math.sin(a) * speed,
            size: rand(8, 14),
            rot: rand(0, Math.PI*2),
            vr: rand(10, 20), // Fast spin!
            life: 999, // Infinite life - removed by off-screen check instead
            hue: (i * 360 / 7) % 360, // Rainbow spectrum
            gravity: 0.1, // Minimal gravity
            noDrag: true, // Flag to skip drag entirely
            bubblesPopped: 0, // Track how many it's popped
            maxPops: 2, // Can only pop 2 bubbles
          });
        }
        
        // Add sparkle trails
        for (let i=0; i<30; i++) {
          const a = rand(0, Math.PI*2);
          const s = rand(3, 8);
          state.particles.push({
            kind: "circle",
            x, y,
            vx: Math.cos(a)*s,
            vy: Math.sin(a)*s,
            r: rand(1, 3),
            life: rand(0.3, 0.8),
            hue: rand(0, 360),
            gravity: 1.5,
            fadeType: 2,
          });
        }
        break;
    }
  }

  // Create a scaled shockwave based on bubble size
  function createScaledShockwave(x, y, bubbleRadius, hue, chainId = null) {
    // Scale the shockwave properties based on bubble size
    // Smaller bubbles = smaller, faster shockwaves
    // Larger bubbles = larger, slower shockwaves
    const sizeScale = bubbleRadius / 50; // Normalize to typical bubble size
    const numRings = Math.max(1, Math.floor(sizeScale * 3)); // 1-3 rings based on size
    const maxRadius = bubbleRadius * 3; // Shockwave reaches 3x bubble radius
    
    for (let i = 0; i < numRings; i++) {
      setTimeout(() => {
        const shockwave = {
          kind: "ring",
          x, y,
          r: bubbleRadius * 0.2,
          growSpeed: (3 + sizeScale * 2) * (1 + i * 0.2), // Faster for bigger bubbles
          life: 0.6 + sizeScale * 0.4, // Lives longer based on size
          hue: hue + i * 40,
          fadeType: i % 3,
          isShockwave: true,
          origin: { x, y },
          maxRadius: maxRadius, // Stop expanding at this radius
          chainId: chainId, // Propagate chain ID
        };
        state.particles.push(shockwave);
      }, i * 40);
    }
  }

  // Create intense chain display text
  function createChainDisplay(x, y, count, chainId) {
    const displayIndex = state.chainDisplays.length;
    state.chainDisplays.push({
      x,
      y: y - 20, // Start slightly above
      count,
      life: 1.5, // Lives for 1.5 seconds
      scale: 0.5, // Start small
      maxScale: 1.5 + count * 0.2, // Bigger for longer chains
      vy: -50, // Float upward
    });
    
    // Track this chain
    activeChains.set(chainId, {
      count,
      displayIndex,
      originX: x,
      originY: y,
    });
    
    // Clean up chain data when display expires
    setTimeout(() => {
      activeChains.delete(chainId);
    }, 1500);
  }

  // ---------------- Input Handling (Multi-touch support) ----------------
  let activePointers = new Map(); // pointerId -> { x, y, lastX, lastY }
  let dragTrail = [];

  function handlePointerDown(e) {
    // Always try to resume audio context on user interaction (iOS requirement)
    if (audioCtx && audioCtx.state === "suspended") {
      audioCtx.resume();
    }
    
    if (!audioPrimed) {
      ensureAudio();
      playPopSound(0);
    }

    const x = e.clientX;
    const y = e.clientY;
    const pointerId = e.pointerId;
    
    // Track this pointer
    activePointers.set(pointerId, {
      x: x,
      y: y,
      lastX: x,
      lastY: y
    });
    
    // Add to trail
    dragTrail.push({ x: x, y: y, time: performance.now() });

    // Check for bubble hit
    checkBubbleHit(x, y);
  }

  function handlePointerMove(e) {
    const pointerId = e.pointerId;
    if (!activePointers.has(pointerId)) return;
    
    const x = e.clientX;
    const y = e.clientY;
    const pointer = activePointers.get(pointerId);
    
    // Add to trail
    dragTrail.push({ x: x, y: y, time: performance.now() });
    if (dragTrail.length > 60) { // Increased for multi-finger trails
      dragTrail.shift();
    }
    
    // Check for bubbles along the drag path
    const dx = x - pointer.lastX;
    const dy = y - pointer.lastY;
    const dist = Math.hypot(dx, dy);
    
    // Check multiple points along the drag path
    const steps = Math.max(1, Math.floor(dist / 10));
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const checkX = pointer.lastX + dx * t;
      const checkY = pointer.lastY + dy * t;
      checkBubbleHit(checkX, checkY);
    }
    
    // Update pointer position
    pointer.lastX = x;
    pointer.lastY = y;
    pointer.x = x;
    pointer.y = y;
  }

  function handlePointerUp(e) {
    const pointerId = e.pointerId;
    activePointers.delete(pointerId);
  }

  function checkBubbleHit(x, y) {
    // Check for bubble hit
    for (let i = state.bubbles.length - 1; i >= 0; i--) {
      const b = state.bubbles[i];
      const dx = x - b.x;
      const dy = y - b.y;
      const dist = Math.hypot(dx, dy);

      if (dist < b.r) {
        explodeBubble(b);
        const pointsEarned = b.type.points * Math.max(1, combo);
        updateScore(pointsEarned);
        state.bubbles.splice(i, 1);
        return; // Only pop one bubble per hit check
      }
    }
  }

  canvas.addEventListener("pointerdown", handlePointerDown, { passive: true });
  canvas.addEventListener("pointermove", handlePointerMove, { passive: true });
  canvas.addEventListener("pointerup", handlePointerUp, { passive: true });
  canvas.addEventListener("pointercancel", handlePointerUp, { passive: true });

  // ---------------- Update ----------------
  function update(dt) {
    // Update bubbles
    for (let i = state.bubbles.length - 1; i >= 0; i--) {
      const b = state.bubbles[i];
      b.phase += dt * b.wiggleSpeed;
      b.x += (b.vx + Math.sin(b.phase) * b.wiggleAmp) * 60 * dt;
      b.y += b.vy * 60 * dt;

      // Remove if off screen
      if (b.y + b.r < -10) {
        state.bubbles.splice(i, 1);
        bubbleEscaped();
      }
    }

    // Update particles
    for (let i = state.particles.length - 1; i >= 0; i--) {
      const p = state.particles[i];
      p.life -= dt;

      if (p.kind === "ring") {
        const oldR = p.r;
        p.r += p.growSpeed * 60 * dt;
        
        // Stop growing if we hit max radius
        if (p.maxRadius && p.r > p.maxRadius) {
          p.r = p.maxRadius;
          p.life = Math.min(p.life, 0.2); // Start fading out quickly
        }
        
        // Check for shockwave collisions with bubbles (only check newly expanded area)
        if (p.isShockwave && p.origin && p.r <= (p.maxRadius || Infinity)) {
          for (let j = state.bubbles.length - 1; j >= 0; j--) {
            const b = state.bubbles[j];
            const dx = b.x - p.origin.x;
            const dy = b.y - p.origin.y;
            const distFromCenter = Math.hypot(dx, dy);
            
            // Check if bubble is within the expanding ring (with some thickness)
            const ringThickness = 20;
            if (Math.abs(distFromCenter - p.r) < ringThickness + b.r) {
              const chainId = p.chainId;
              
              if (chainId) {
                // Increment chain count
                const chainData = activeChains.get(chainId);
                if (chainData) {
                  chainData.count++;
                  
                  // Create display on first hit, update on subsequent hits
                  if (chainData.displayIndex === -1) {
                    // First hit - create the display!
                    const displayIndex = state.chainDisplays.length;
                    state.chainDisplays.push({
                      x: chainData.originX,
                      y: chainData.originY - 20,
                      count: chainData.count,
                      life: 1.5,
                      scale: 0.5,
                      maxScale: 1.5 + chainData.count * 0.2,
                      vy: -50,
                    });
                    chainData.displayIndex = displayIndex;
                  } else {
                    // Update the existing display
                    if (state.chainDisplays[chainData.displayIndex]) {
                      state.chainDisplays[chainData.displayIndex].count = chainData.count;
                      state.chainDisplays[chainData.displayIndex].life = 1.5; // Reset life
                    }
                  }
                }
              }
              
              // Pop the bubble!
              explodeBubble(b);
              const pointsEarned = Math.floor(b.type.points * 0.5); // Half points for chain pops
              updateScore(pointsEarned);
              
              // Create a scaled shockwave from this bubble with chain ID
              createScaledShockwave(b.x, b.y, b.r, b.hue, chainId);
              
              state.bubbles.splice(j, 1);
            }
          }
        }
      } else {
        p.x += p.vx * 60 * dt;
        p.y += p.vy * 60 * dt;
        
        if (p.gravity !== undefined) {
          p.vy += p.gravity * dt;
        }

        if (p.vr !== undefined) {
          p.rot += p.vr * dt;
        }

        if (p.kind === "blob") {
          p.phase += dt * p.wobbleSpeed;
        }

        if (p.kind === "star") {
          p.twinkle += dt * 10;
        }

        if (p.kind === "trail") {
          p.trail.push({x: p.x, y: p.y});
          if (p.trail.length > 8) p.trail.shift();
        }
        
        // Star projectiles check for bubble collisions!
        if (p.kind === "starProjectile" && p.bubblesPopped < p.maxPops) {
          for (let j = state.bubbles.length - 1; j >= 0; j--) {
            const b = state.bubbles[j];
            const dx = p.x - b.x;
            const dy = p.y - b.y;
            const dist = Math.hypot(dx, dy);
            
            // Check collision with bubble (star size + bubble radius)
            if (dist < p.size + b.r) {
              // Pop the bubble!
              explodeBubble(b);
              const pointsEarned = Math.floor(b.type.points * 0.5); // Half points for star pops
              updateScore(pointsEarned);
              state.bubbles.splice(j, 1);
              
              // Increment pop counter
              p.bubblesPopped++;
              
              // Create sparkle burst at collision
              for (let k = 0; k < 8; k++) {
                const angle = rand(0, Math.PI * 2);
                const speed = rand(2, 5);
                state.particles.push({
                  kind: "circle",
                  x: b.x,
                  y: b.y,
                  vx: Math.cos(angle) * speed,
                  vy: Math.sin(angle) * speed,
                  r: rand(1, 3),
                  life: rand(0.2, 0.5),
                  hue: p.hue,
                  gravity: 1.0,
                  fadeType: 2,
                });
              }
              
              // If reached max pops, fade out quickly
              if (p.bubblesPopped >= p.maxPops) {
                p.life = 0.3; // Short fade
              }
              
              break; // Only pop one bubble per frame
            }
          }
        }
        
        // Remove star projectiles that go off-screen
        if (p.kind === "starProjectile") {
          const margin = 100; // Extra margin beyond screen
          if (p.x < -margin || p.x > innerWidth + margin || 
              p.y < -margin || p.y > innerHeight + margin) {
            p.life = 0; // Remove it
          }
        }
        
        // Firework particles have air drag
        if (p.kind === "firework" && p.drag) {
          p.vx *= (1 - p.drag);
          p.vy *= (1 - p.drag);
        } else if (p.noDrag) {
          // Stars and other noDrag particles - no velocity decay!
          // They keep their momentum
        } else {
          // Regular drag for other particles
          p.vx *= (1 - 0.8 * dt);
          p.vy *= (1 - 0.8 * dt);
        }
      }

      if (p.life <= 0) {
        state.particles.splice(i, 1);
      }
    }

    // Combo timer
    if (comboTimer > 0) {
      comboTimer -= dt;
      if (comboTimer <= 0) {
        combo = 0;
        comboEl.classList.remove("active");
      }
    }
    
    // Update chain displays
    for (let i = state.chainDisplays.length - 1; i >= 0; i--) {
      const d = state.chainDisplays[i];
      d.life -= dt;
      d.y += d.vy * dt;
      
      // Update maxScale as count increases
      d.maxScale = 1.5 + d.count * 0.2;
      
      // Animate scale (pop in, then settle)
      const lifeProgress = 1 - (d.life / 1.5);
      if (lifeProgress < 0.2) {
        // Pop in
        d.scale = lerp(0.5, d.maxScale, lifeProgress / 0.2);
      } else if (lifeProgress < 0.4) {
        // Settle back
        d.scale = lerp(d.maxScale, d.maxScale * 0.9, (lifeProgress - 0.2) / 0.2);
      } else {
        // Stay at settled size, but grow if count increases
        const targetScale = d.maxScale * 0.9;
        d.scale = lerp(d.scale, targetScale, dt * 10); // Smooth interpolation
      }
      
      // Slow down upward movement
      d.vy *= (1 - 2.0 * dt);
      
      // Remove if dead
      if (d.life <= 0) {
        state.chainDisplays.splice(i, 1);
      }
    }
    
    // Clean up old trail points
    if (activePointers.size === 0 && dragTrail.length > 0) {
      var now = performance.now();
      dragTrail = dragTrail.filter(function(point) {
        return (now - point.time) < 500;
      });
    }
    
    // Update note effect particles
    for (let i = state.noteEffectParticles.length - 1; i >= 0; i--) {
      const p = state.noteEffectParticles[i];
      p.life -= dt;
      
      if (p.life <= 0) {
        state.noteEffectParticles.splice(i, 1);
        continue;
      }
      
      // Update position
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      
      // Apply gravity for some types
      if (p.type === "confetti" || p.type === "bubble") {
        p.vy += 100 * dt; // gravity
      }
      
      // Update rotation
      if (p.vr !== undefined) {
        p.rot += p.vr * dt;
      }
      
      // Slow down
      p.vx *= (1 - 1.5 * dt);
      p.vy *= (1 - 1.5 * dt);
    }
  }

  // ---------------- Musical Staff Helper ----------------
  function getStaffPosition(frequency) {
    // Map frequency to staff position (0 = middle C line, + goes up, - goes down)
    // Each position is a half step (semitone)
    const C4 = 262;
    const semitones = Math.round(12 * Math.log2(frequency / C4));
    return semitones;
  }

  function drawMusicalStaff() {
    const song = songs[currentSongIndex];
    const notes = song.notes;
    
    // Staff dimensions
    const staffX = innerWidth * 0.1;
    const staffY = 140;
    const staffWidth = innerWidth * 0.8;
    const staffHeight = 80;
    const lineSpacing = staffHeight / 8; // 5 lines = 4 spaces, plus margins
    
    ctx.save();
    ctx.globalAlpha = 0.4;
    
    // Draw staff lines (5 lines)
    ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
    ctx.lineWidth = 1.5;
    for (let i = 0; i < 5; i++) {
      const y = staffY + lineSpacing + i * lineSpacing;
      ctx.beginPath();
      ctx.moveTo(staffX, y);
      ctx.lineTo(staffX + staffWidth, y);
      ctx.stroke();
    }
    
    // Calculate note spacing and pagination
    const notesPerPage = 15; // Show 15 notes per page
    const noteSpacing = staffWidth / (notesPerPage - 1);
    
    // Calculate which page we're on
    const currentPage = Math.floor(currentNoteIndex / notesPerPage);
    const startIdx = currentPage * notesPerPage;
    const endIdx = Math.min(notes.length, startIdx + notesPerPage);
    
    // Position within current page
    const positionInPage = currentNoteIndex - startIdx;
    const playheadX = staffX + positionInPage * noteSpacing;
    
    // Draw playhead line
    ctx.globalAlpha = 0.8;
    const pulse = Math.sin(performance.now() * 0.01) * 0.2 + 0.8;
    ctx.strokeStyle = `rgba(140, 255, 210, ${pulse})`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(playheadX, staffY);
    ctx.lineTo(playheadX, staffY + staffHeight);
    ctx.stroke();
    
    // Draw notes for current page
    for (let i = startIdx; i < endIdx; i++) {
      const freq = notes[i];
      const staffPos = getStaffPosition(freq);
      
      // Convert staff position to Y coordinate
      // staffPos 0 (C4) = between 3rd and 4th line (space)
      // Each staffPos = quarter of a lineSpacing (half step)
      const noteY = staffY + lineSpacing * 3 - (staffPos * lineSpacing / 2);
      const noteX = staffX + (i - startIdx) * noteSpacing;
      
      // Determine note state
      const isCurrent = (i === currentNoteIndex);
      const isPast = (i < currentNoteIndex);
      
      // Apply visual effect to current note
      let effectOffsetX = 0;
      let effectOffsetY = 0;
      let effectScale = 1;
      let effectRotation = 0;
      let effectAlpha = 1;
      let effectColor = null;
      
      if (isCurrent) {
        const effect = noteEffects[currentEffectIndex];
        const t = performance.now() * 0.001; // time in seconds
        
        switch(effect) {
          case "bounce":
            // Bounce up and down
            effectOffsetY = Math.abs(Math.sin(t * 10)) * -15;
            break;
            
          case "wobble":
            // Wiggle side to side
            effectOffsetX = Math.sin(t * 8) * 8;
            break;
            
          case "growPulse":
            // Scale bigger and smaller
            effectScale = 1 + Math.sin(t * 8) * 0.5;
            break;
            
          case "spinning":
            // Rotate
            effectRotation = t * 4;
            break;
            
          case "sparkleBurst":
            // Spawn sparkle particles
            if (Math.random() < 0.3) {
              const angle = rand(0, Math.PI * 2);
              const speed = rand(20, 50);
              state.noteEffectParticles.push({
                type: "star",
                x: noteX,
                y: noteY,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: rand(0.3, 0.6),
                maxLife: 0.6,
                size: rand(2, 4),
                hue: rand(0, 360),
              });
            }
            effectScale = 1.2;
            break;
            
          case "confettiPop":
            // Spawn confetti particles
            if (Math.random() < 0.2) {
              const angle = rand(0, Math.PI * 2);
              const speed = rand(15, 40);
              state.noteEffectParticles.push({
                type: "confetti",
                x: noteX,
                y: noteY,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: rand(0.4, 0.8),
                maxLife: 0.8,
                size: rand(3, 6),
                rot: rand(0, Math.PI * 2),
                vr: rand(-10, 10),
                hue: rand(0, 360),
              });
            }
            effectScale = 1.3 + Math.sin(t * 15) * 0.2;
            break;
            
          case "bubbleTrail":
            // Spawn bubble particles
            if (Math.random() < 0.25) {
              state.noteEffectParticles.push({
                type: "bubble",
                x: noteX + rand(-5, 5),
                y: noteY,
                vx: rand(-5, 5),
                vy: rand(-30, -50),
                life: rand(0.5, 1.0),
                maxLife: 1.0,
                size: rand(3, 8),
                hue: rand(180, 220),
              });
            }
            break;
            
          case "rainbowTrail":
            // Spawn rainbow trail particles
            if (Math.random() < 0.4) {
              state.noteEffectParticles.push({
                type: "trail",
                x: noteX + rand(-8, 8),
                y: noteY + rand(-8, 8),
                vx: rand(-10, 10),
                vy: rand(-10, 10),
                life: rand(0.3, 0.6),
                maxLife: 0.6,
                size: rand(2, 5),
                hue: (t * 100) % 360,
              });
            }
            effectColor = `hsl(${(t * 100) % 360}, 90%, 70%)`;
            break;
            
          case "pulsingGlow":
            // Pulsing glow effect
            effectScale = 1 + Math.sin(t * 10) * 0.4;
            effectAlpha = 0.7 + Math.sin(t * 10) * 0.3;
            break;
            
          case "colorWave":
            // Cycle through colors
            effectColor = `hsl(${(t * 180) % 360}, 95%, 70%)`;
            effectScale = 1.3;
            break;
            
          case "shimmer":
            // Glittery sparkle
            effectAlpha = 0.6 + Math.random() * 0.4;
            effectScale = 1.2 + Math.random() * 0.3;
            break;
            
          case "lightBeam":
            // Vertical beam (drawn separately below)
            effectScale = 1.4;
            // Draw beam
            ctx.save();
            ctx.globalAlpha = 0.3 * pulse;
            const beamGradient = ctx.createLinearGradient(noteX, noteY, noteX, staffY - 50);
            beamGradient.addColorStop(0, "rgba(140, 255, 210, 0.6)");
            beamGradient.addColorStop(1, "rgba(140, 255, 210, 0)");
            ctx.fillStyle = beamGradient;
            ctx.fillRect(noteX - 10, staffY - 50, 20, noteY - (staffY - 50));
            ctx.restore();
            break;
            
          case "bouncingSparkles":
            // Combine bounce + sparkles
            effectOffsetY = Math.abs(Math.sin(t * 10)) * -15;
            if (Math.random() < 0.3) {
              const angle = rand(0, Math.PI * 2);
              const speed = rand(20, 50);
              state.noteEffectParticles.push({
                type: "star",
                x: noteX,
                y: noteY + effectOffsetY,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: rand(0.3, 0.6),
                maxLife: 0.6,
                size: rand(2, 4),
                hue: rand(40, 80),
              });
            }
            effectScale = 1.2;
            break;
            
          case "growingGlow":
            // Growing with glow ring
            effectScale = 1 + Math.sin(t * 8) * 0.6;
            // Draw glow ring
            ctx.save();
            ctx.globalAlpha = 0.4 * (1 - (effectScale - 1) / 0.6);
            ctx.strokeStyle = `rgba(140, 255, 210, ${0.8 * (1 - (effectScale - 1) / 0.6)})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(noteX + effectOffsetX, noteY + effectOffsetY, 10 * effectScale, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
            break;
            
          case "rainbowSpiral":
            // Colorful spiral particles
            if (Math.random() < 0.3) {
              const angle = t * 3;
              const radius = (Math.sin(t * 5) + 1) * 15;
              state.noteEffectParticles.push({
                type: "spiral",
                x: noteX + Math.cos(angle) * radius,
                y: noteY + Math.sin(angle) * radius,
                vx: Math.cos(angle) * 10,
                vy: Math.sin(angle) * 10,
                life: rand(0.4, 0.7),
                maxLife: 0.7,
                size: rand(2, 5),
                hue: (angle * 50 + t * 100) % 360,
              });
            }
            effectColor = `hsl(${(t * 150) % 360}, 95%, 70%)`;
            break;
        }
        
        // Apply effect transformations
        ctx.save();
        ctx.globalAlpha = 0.9 * pulse * effectAlpha;
        ctx.shadowBlur = 20 * effectScale;
        ctx.shadowColor = "rgba(140, 255, 210, 0.8)";
        ctx.translate(noteX + effectOffsetX, noteY + effectOffsetY);
        ctx.rotate(effectRotation);
        ctx.scale(effectScale, effectScale);
      } else if (isPast) {
        // Past notes - dimmed
        ctx.globalAlpha = 0.2;
        ctx.shadowBlur = 0;
      } else {
        // Future notes - medium brightness
        ctx.globalAlpha = 0.5;
        ctx.shadowBlur = 0;
      }
      
      // Draw note head (filled circle)
      const noteColor = effectColor || (isCurrent ? "rgba(140, 255, 210, 1)" : 
                      isPast ? "rgba(180, 180, 200, 0.6)" : 
                      "rgba(255, 255, 255, 0.8)");
      ctx.fillStyle = noteColor;
      ctx.beginPath();
      ctx.arc(isCurrent ? 0 : noteX, isCurrent ? 0 : noteY, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw stem
      ctx.strokeStyle = isCurrent ? noteColor : ctx.fillStyle;
      ctx.lineWidth = isCurrent ? 2 : 1.5;
      ctx.beginPath();
      ctx.moveTo((isCurrent ? 0 : noteX) + 5, isCurrent ? 0 : noteY);
      ctx.lineTo((isCurrent ? 0 : noteX) + 5, (isCurrent ? 0 : noteY) - (isCurrent ? 30 : 25));
      ctx.stroke();
      
      if (isCurrent) {
        ctx.restore();
      }
      
      // Draw ledger lines if note is outside staff
      if (noteY < staffY + lineSpacing || noteY > staffY + lineSpacing * 5) {
        ctx.globalAlpha = 0.4;
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.lineWidth = 1.5;
        
        // Determine which ledger lines to draw
        const ledgerY = Math.round((noteY - (staffY + lineSpacing)) / lineSpacing) * lineSpacing + (staffY + lineSpacing);
        ctx.beginPath();
        ctx.moveTo(noteX - 8, ledgerY);
        ctx.lineTo(noteX + 8, ledgerY);
        ctx.stroke();
      }
    }
    
    ctx.shadowBlur = 0;
    ctx.restore();
    
    // Draw note effect particles
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (const p of state.noteEffectParticles) {
      const alpha = p.life / p.maxLife;
      ctx.globalAlpha = alpha;
      
      if (p.type === "star") {
        ctx.fillStyle = `hsl(${p.hue}, 95%, 75%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const ang = (i / 5) * Math.PI * 2;
          const r = i % 2 === 0 ? p.size : p.size * 0.4;
          ctx.lineTo(Math.cos(ang) * r, Math.sin(ang) * r);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      } else if (p.type === "confetti") {
        ctx.fillStyle = `hsl(${p.hue}, 90%, 65%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillRect(-p.size / 2, -p.size, p.size, p.size * 2);
        ctx.restore();
      } else if (p.type === "bubble") {
        ctx.strokeStyle = `hsla(${p.hue}, 80%, 65%, ${alpha})`;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.stroke();
      } else if (p.type === "trail" || p.type === "spiral") {
        ctx.fillStyle = `hsl(${p.hue}, 95%, 70%)`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    ctx.restore();
  }

  // ---------------- Draw ----------------
  function draw() {
    // Background
    ctx.fillStyle = "rgba(10, 5, 32, 0.15)";
    ctx.fillRect(0, 0, innerWidth, innerHeight);
    
    // Draw musical staff
    drawMusicalStaff();
    
    // Draw drag trail
    if (dragTrail.length > 1) {
      var trailNow = performance.now();
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      
      for (var i = 1; i < dragTrail.length; i++) {
        var p1 = dragTrail[i - 1];
        var p2 = dragTrail[i];
        
        var age1 = (trailNow - p1.time) / 500;
        var age2 = (trailNow - p2.time) / 500;
        var alpha1 = Math.max(0, 1 - age1);
        var alpha2 = Math.max(0, 1 - age2);
        
        if (alpha1 > 0 && alpha2 > 0) {
          var hue1 = (p1.x * 0.3 + p1.y * 0.2 + trailNow * 0.1) % 360;
          var hue2 = (p2.x * 0.3 + p2.y * 0.2 + trailNow * 0.1) % 360;
          
          var gradient = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
          gradient.addColorStop(0, "hsla(" + hue1 + ", 100%, 70%, " + (alpha1 * 0.3) + ")");
          gradient.addColorStop(1, "hsla(" + hue2 + ", 100%, 70%, " + (alpha2 * 0.3) + ")");
          
          ctx.strokeStyle = gradient;
          ctx.lineWidth = 20;
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
          
          var innerGradient = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
          innerGradient.addColorStop(0, "hsla(" + hue1 + ", 100%, 85%, " + (alpha1 * 0.6) + ")");
          innerGradient.addColorStop(1, "hsla(" + hue2 + ", 100%, 85%, " + (alpha2 * 0.6) + ")");
          
          ctx.strokeStyle = innerGradient;
          ctx.lineWidth = 8;
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }
      }
      
      if (activePointers.size > 0 && dragTrail.length > 0) {
        var latest = dragTrail[dragTrail.length - 1];
        if (Math.random() < 0.4) {
          var hue = (latest.x * 0.3 + latest.y * 0.2 + trailNow * 0.1) % 360;
          state.particles.push({
            kind: "star",
            x: latest.x + rand(-5, 5),
            y: latest.y + rand(-5, 5),
            vx: rand(-0.5, 0.5),
            vy: rand(-0.5, 0.5),
            r: rand(2, 5),
            life: rand(0.3, 0.6),
            hue: hue,
            fadeType: 2
          });
        }
      }
      
      ctx.restore();
    }

    // Draw particles
    ctx.save();
    ctx.globalCompositeOperation = "lighter";

    for (const p of state.particles) {
      // Different fade types
      let a;
      const fadeType = p.fadeType || 0;
      if (fadeType === 0) {
        // Linear fade
        a = clamp(p.life / 0.4, 0, 1);
      } else if (fadeType === 1) {
        // Slow start fade (stays bright longer)
        const t = clamp(p.life / 0.5, 0, 1);
        a = t * t;
      } else {
        // Fast start fade (quick fade out)
        const t = clamp(p.life / 0.3, 0, 1);
        a = Math.sqrt(t);
      }

      if (p.kind === "circle") {
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 85%, 65%)`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.fill();
      } 
      else if (p.kind === "glow") {
        // Glowing orb with radial gradient
        ctx.globalAlpha = a * 0.8;
        const grd = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r);
        grd.addColorStop(0, `hsla(${p.hue}, 95%, 85%, 1)`);
        grd.addColorStop(0.5, `hsla(${p.hue}, 90%, 70%, 0.6)`);
        grd.addColorStop(1, `hsla(${p.hue}, 85%, 60%, 0)`);
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r * 1.5, 0, Math.PI*2);
        ctx.fill();
      } 
      else if (p.kind === "ring") {
        ctx.globalAlpha = a * 0.6;
        ctx.strokeStyle = `hsl(${p.hue}, 85%, 70%)`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.stroke();
      }
      else if (p.kind === "shard") {
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 90%, 70%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
        ctx.restore();
      }
      else if (p.kind === "star") {
        const tw = p.twinkle !== undefined ? (0.7 + 0.3 * Math.sin(p.twinkle)) : 1;
        ctx.globalAlpha = a * tw;
        ctx.fillStyle = `hsl(${p.hue}, 95%, 75%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot || 0);
        ctx.beginPath();
        for (let i=0; i<5; i++) {
          const ang = (i/5) * Math.PI * 2;
          const r = i % 2 === 0 ? p.size : p.size * 0.4;
          ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      else if (p.kind === "triangle") {
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 90%, 70%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot || 0);
        ctx.beginPath();
        const s = p.r || p.size;
        ctx.moveTo(0, -s);
        ctx.lineTo(s * 0.866, s * 0.5);
        ctx.lineTo(-s * 0.866, s * 0.5);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      else if (p.kind === "diamond") {
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 92%, 72%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot || 0);
        ctx.beginPath();
        const s = p.size || p.r;
        ctx.moveTo(0, -s);
        ctx.lineTo(s * 0.6, 0);
        ctx.lineTo(0, s);
        ctx.lineTo(-s * 0.6, 0);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      else if (p.kind === "blob") {
        const wobble = Math.sin(p.phase) * 0.2 + 1;
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 85%, 65%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.scale(wobble, 1/wobble);
        ctx.beginPath();
        ctx.arc(0, 0, p.r, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      else if (p.kind === "confetti") {
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 90%, 65%)`;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
        ctx.restore();
      }
      else if (p.kind === "trail") {
        ctx.globalAlpha = a;
        ctx.strokeStyle = `hsl(${p.hue}, 90%, 70%)`;
        ctx.lineWidth = p.r;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.beginPath();
        for (let i=0; i<p.trail.length; i++) {
          const pt = p.trail[i];
          if (i === 0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
        }
        ctx.stroke();
        
        // Draw head
        ctx.fillStyle = `hsl(${p.hue}, 95%, 75%)`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r * 1.2, 0, Math.PI*2);
        ctx.fill();
      }
      else if (p.kind === "firework") {
        // Glowing firework particle (from touchy-effects)
        const a = clamp(p.life / 0.35, 0, 1) * (p.glow || 0.8);
        ctx.fillStyle = `hsla(${p.hue}, 95%, 70%, ${a})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r * (0.7 + a * 0.5), 0, Math.PI*2);
        ctx.fill();
      }
      else if (p.kind === "starProjectile") {
        // Spinning star projectile that bursts bubbles!
        const a = clamp(p.life / 0.5, 0, 1);
        
        // Draw glow behind star
        ctx.globalAlpha = a * 0.4;
        const glowGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2);
        glowGrad.addColorStop(0, `hsla(${p.hue}, 100%, 70%, 0.6)`);
        glowGrad.addColorStop(1, `hsla(${p.hue}, 100%, 70%, 0)`);
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw the spinning star
        ctx.globalAlpha = a;
        ctx.fillStyle = `hsl(${p.hue}, 100%, 75%)`;
        ctx.strokeStyle = `hsl(${p.hue}, 100%, 90%)`;
        ctx.lineWidth = 2;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot || 0);
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const ang = (i / 5) * Math.PI * 2;
          const r = i % 2 === 0 ? p.size : p.size * 0.4;
          ctx.lineTo(Math.cos(ang) * r, Math.sin(ang) * r);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();
        
        // Fade out if reached max pops
        if (p.bubblesPopped >= p.maxPops) {
          ctx.globalAlpha = a * 0.3;
        }
      }
    }
    ctx.restore();

    // Draw bubbles
    ctx.save();
    const now = performance.now();
    for (const b of state.bubbles) {
      const hue = b.hue;
      
      // All bubbles create shockwaves, so they all pulse!
      // Pulse effect based on time and bubble size
      const pulseSpeed = 2.0 + (b.r / 50); // Bigger bubbles pulse slower
      const pulse = Math.sin(now * 0.003 * pulseSpeed) * 0.15 + 1; // 0.85 to 1.15
      
      // Outer glow (pulses)
      ctx.globalAlpha = 0.3 * pulse;
      const glowSize = b.r * 1.3 * pulse;
      const glow = ctx.createRadialGradient(b.x, b.y, b.r * 0.5, b.x, b.y, glowSize);
      glow.addColorStop(0, `hsla(${hue}, 85%, 70%, 0.4)`);
      glow.addColorStop(1, `hsla(${hue}, 85%, 70%, 0)`);
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(b.x, b.y, glowSize, 0, Math.PI*2);
      ctx.fill();
      
      // Pulsing energy ring around bubble
      ctx.globalAlpha = 0.4 * pulse;
      ctx.strokeStyle = `hsla(${hue}, 90%, 75%, ${0.6 * pulse})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r * (1.1 + pulse * 0.1), 0, Math.PI*2);
      ctx.stroke();

      // Main bubble
      ctx.globalAlpha = 0.6;
      ctx.strokeStyle = `hsla(${hue}, 80%, 65%, 0.9)`;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.stroke();

      // Highlight
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = `hsla(${hue}, 90%, 85%, 0.6)`;
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.3, b.y - b.r*0.3, b.r*0.3, 0, Math.PI*2);
      ctx.fill();

      // Small highlight
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = `hsla(${hue}, 95%, 95%, 0.8)`;
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.4, b.y - b.r*0.4, b.r*0.15, 0, Math.PI*2);
      ctx.fill();
      
      // Draw stars inside fireworks bubbles!
      if (b.type && b.type.hasStars) {
        ctx.save();
        ctx.globalAlpha = 0.7;
        const numStars = Math.floor(b.r / 10); // More stars for bigger bubbles
        for (let i = 0; i < numStars; i++) {
          const angle = (now * 0.001 + i * (Math.PI * 2 / numStars)) % (Math.PI * 2);
          const radius = b.r * 0.4;
          const sx = b.x + Math.cos(angle) * radius;
          const sy = b.y + Math.sin(angle) * radius;
          const starSize = b.r * 0.12;
          const starHue = (now * 0.1 + i * 60) % 360; // Rainbow colors
          
          ctx.fillStyle = `hsla(${starHue}, 100%, 75%, ${0.8 + Math.sin(now * 0.005 + i) * 0.2})`;
          ctx.save();
          ctx.translate(sx, sy);
          ctx.rotate(now * 0.002 + i);
          ctx.beginPath();
          for (let j = 0; j < 5; j++) {
            const ang = (j / 5) * Math.PI * 2;
            const r = j % 2 === 0 ? starSize : starSize * 0.4;
            ctx.lineTo(Math.cos(ang) * r, Math.sin(ang) * r);
          }
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        ctx.restore();
      }
    }
    ctx.restore();
    
    // Draw chain reaction displays (on top of everything)
    ctx.save();
    for (const d of state.chainDisplays) {
      const alpha = clamp(d.life / 0.5, 0, 1); // Fade out in last 0.5 seconds
      
      ctx.globalAlpha = alpha;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      
      // Calculate colors based on chain length
      const hue = 30 + d.count * 15; // Yellow to red spectrum
      
      // Outer glow
      ctx.shadowBlur = 20 * d.scale;
      ctx.shadowColor = `hsla(${hue}, 100%, 50%, ${alpha})`;
      
      // Main text
      const fontSize = Math.floor(40 * d.scale);
      ctx.font = `900 ${fontSize}px system-ui, -apple-system, sans-serif`;
      ctx.fillStyle = `hsla(${hue}, 100%, 60%, 1)`;
      ctx.fillText(`${d.count}x CHAIN!`, d.x, d.y);
      
      // Inner highlight
      ctx.shadowBlur = 0;
      ctx.fillStyle = `hsla(${hue + 30}, 100%, 85%, ${alpha * 0.8})`;
      ctx.fillText(`${d.count}x CHAIN!`, d.x, d.y - 2);
      
      // Impact lines (if chain is big enough)
      if (d.count >= 3) {
        ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${alpha * 0.6})`;
        ctx.lineWidth = 3 * d.scale;
        const lineLength = 30 * d.scale;
        for (let i = 0; i < 4; i++) {
          const angle = (i / 4) * Math.PI * 2 + performance.now() * 0.01;
          const x1 = d.x + Math.cos(angle) * (fontSize * 0.8);
          const y1 = d.y + Math.sin(angle) * (fontSize * 0.5);
          const x2 = d.x + Math.cos(angle) * (fontSize * 0.8 + lineLength);
          const y2 = d.y + Math.sin(angle) * (fontSize * 0.5 + lineLength);
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
      }
    }
    ctx.restore();
  }

  // ---------------- Bubble Spawner ----------------
  let spawnTimer = 0;
  const BASE_SPAWN_INTERVAL = 0.4; // Faster spawn! (was 0.8)
  const MAX_BUBBLES = 20; // Allow more bubbles (was 15)
  const CROWDED_THRESHOLD = 16; // Start slowing down here (was 12)

  function spawnLoop(dt) {
    const bubbleCount = state.bubbles.length;
    
    // Calculate density penalty
    let densityMultiplier = 1.0;
    if (bubbleCount >= CROWDED_THRESHOLD) {
      // Slow down spawning as we approach max bubbles
      const overflow = (bubbleCount - CROWDED_THRESHOLD) / (MAX_BUBBLES - CROWDED_THRESHOLD);
      densityMultiplier = 1.0 + (overflow * 3.0); // Up to 4x slower
    }
    
    // Don't spawn at all if we're at or above max
    if (bubbleCount >= MAX_BUBBLES) {
      return;
    }
    
    // Adjust spawn rate based on difficulty and density
    const currentInterval = (BASE_SPAWN_INTERVAL / difficultyLevel) * densityMultiplier;
    
    spawnTimer += dt;
    if (spawnTimer >= currentInterval) {
      spawnTimer = 0;
      spawnBubble();
      
      // At higher difficulties, sometimes spawn multiple bubbles
      // But respect density limits
      if (difficultyLevel >= 2.0 && Math.random() < 0.3 && bubbleCount < CROWDED_THRESHOLD) {
        setTimeout(() => spawnBubble(), 100);
      }
      if (difficultyLevel >= 2.5 && Math.random() < 0.2 && bubbleCount < CROWDED_THRESHOLD - 2) {
        setTimeout(() => spawnBubble(), 200);
      }
    }
  }

  // ---------------- Animation Loop ----------------
  let last = performance.now();

  function frame(now) {
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    adjustDifficulty(dt);
    update(dt);
    spawnLoop(dt);
    draw();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // Start with a few bubbles
  for (let i=0; i<3; i++) {
    setTimeout(() => spawnBubble(), i * 300);
  }
})();
</script>
</body>
</html>

